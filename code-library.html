<!-- Page containing code library -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Code Library - CSY2006 C++ Programming</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>CSY2006 C++ Programming Course Notes</h1>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="syllabus.html">Syllabus</a></li>
                <li><a href="code-library.html">Code Library</a></li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle">Weeks <span class="dropdown-arrow">▼</span></a>
                    <ul class="dropdown-menu">
                        <li><a href="week10.html">Week 10: Classes & Objects</a></li>
                        <li><a href="week15.html">Week 15: Advanced Classes</a></li>
                        <li><a href="week16.html">Week 16: Data Structures</a></li>
                        <li><a href="week17.html">Week 17: Expression Evaluation</a></li>
                        <li><a href="week18.html">Week 18: Trees & Graphs</a></li>
                        <li><a href="week19.html">Week 19: Advanced Algorithms</a></li>
                        <li><a href="week20.html">Week 20: File I/O</a></li>
                        <li><a href="week21.html">Week 21: Templates</a></li>
                        <li><a href="week22.html">Week 22: STL</a></li>
                        <li><a href="week23.html">Week 23: Review</a></li>
                    </ul>
                </li>
                <li class="dropdown">
                    <a href="#" class="dropdown-toggle">More <span class="dropdown-arrow">▼</span></a>
                    <ul class="dropdown-menu">
                        <li><a href="mcqs.html">MCQs & Practice</a></li>
                        <li><a href="#resources">Resources</a></li>
                        <li><a href="#practice">Practice Exercises</a></li>
                        <li><a href="#projects">Sample Projects</a></li>
                        <li><a href="#contact">Contact</a></li>
                    </ul>
                </li>
            </ul>
        </nav>
        </nav>
    </header>

    <main>
        <section class="hero">
            <h2>Complete C++ Code Library</h2>
            <p>Comprehensive collection of all sample programs with detailed explanations for beginners</p>
        </section>

        <section id="classes-objects" class="code-section">
            <h2>🔧 Classes and Objects (Week 10)</h2>
            <p class="section-intro">
                <strong>For Beginners:</strong> Think of a class as a blueprint for creating objects, just like a cookie cutter is a blueprint for making cookies.
                Objects are the actual cookies you create using that cutter. Let's explore this concept with real code examples.
            </p>

            <div class="code-example">
                <h3>Simple Account Class Example</h3>
                <p><strong>What it does:</strong> This program creates a bank account system where you can store account information and perform basic operations.</p>
                <p><strong>Why it's useful:</strong> Understanding classes helps you organize your code better, making it easier to manage complex programs.</p>

                <div class="code-block">
                    <pre><code>// Account.h - Header file (the blueprint)
#ifndef ACCOUNT_H
#define ACCOUNT_H

class Account {
private:
    int accountNumber;      // Private data - like a safe
    double balance;         // Only the class can access this directly
    std::string ownerName;  // Account holder's name

public:
    // Constructor - like setting up a new account
    Account(int accNum, std::string name, double initialBalance);

    // Methods - actions you can perform on the account
    void deposit(double amount);    // Add money
    void withdraw(double amount);   // Take money out
    double getBalance() const;      // Check balance
    void displayInfo() const;       // Show account details
};

#endif</code></pre>
                </div>

                <div class="code-block">
                    <pre><code>// Account.cpp - Implementation file (the actual building)
#include "Account.h"
#include &lt;iostream&gt;
#include &lt;iomanip&gt;  // For formatting output

// Constructor implementation
Account::Account(int accNum, std::string name, double initialBalance) {
    accountNumber = accNum;
    ownerName = name;
    balance = initialBalance;
}

// Deposit money into account
void Account::deposit(double amount) {
    if (amount > 0) {
        balance += amount;
        std::cout &lt;&lt; "Deposited: $" &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; amount &lt;&lt; std::endl;
    }
}

// Withdraw money from account
void Account::withdraw(double amount) {
    if (amount > 0 && amount <= balance) {
        balance -= amount;
        std::cout &lt;&lt; "Withdrawn: $" &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; amount &lt;&lt; std::endl;
    } else {
        std::cout &lt;&lt; "Invalid withdrawal amount!" &lt;&lt; std::endl;
    }
}

// Get current balance
double Account::getBalance() const {
    return balance;
}

// Display account information
void Account::displayInfo() const {
    std::cout &lt;&lt; "\n=== Account Information ===" &lt;&lt; std::endl;
    std::cout &lt;&lt; "Account Number: " &lt;&lt; accountNumber &lt;&lt; std::endl;
    std::cout &lt;&lt; "Owner Name: " &lt;&lt; ownerName &lt;&lt; std::endl;
    std::cout &lt;&lt; "Current Balance: $" &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; balance &lt;&lt; std::endl;
}</code></pre>
                </div>

                <div class="explanation">
                    <h4>Understanding the Code:</h4>
                    <ul>
                        <li><strong>Private vs Public:</strong> Private members are like your personal diary - only you can access them. Public members are like a public announcement board.</li>
                        <li><strong>Constructor:</strong> This is the "setup" function that runs when you create a new account object.</li>
                        <li><strong>Methods:</strong> These are actions (functions) that the object can perform.</li>
                        <li><strong>Encapsulation:</strong> This principle protects your data by controlling how it's accessed and modified.</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="data-structures" class="code-section">
            <h2>📊 Data Structures (Week 16)</h2>
            <p class="section-intro">
                <strong>For Beginners:</strong> Data structures are like different types of containers you use to store and organize your data.
                Just like you use different bags for different purposes (backpack for books, shopping bag for groceries), we use different data structures for different needs.
            </p>

            <div class="code-example">
                <h3>Stack Implementation (LIFO)</h3>
                <p><strong>What it does:</strong> A stack is like a stack of plates - you can only add or remove from the top. Last plate in is the first plate out.</p>
                <p><strong>Why it's useful:</strong> Perfect for undo operations, function calls, and expression evaluation.</p>

                <div class="code-block">
                    <pre><code>// Stack.h - Template-based Stack
#ifndef STACK_H
#define STACK_H

template &lt;class T&gt;
class Stack {
private:
    T *stackArray;
    int stackSize;
    int top;

public:
    // Constructor
    Stack(int size = 100) {
        stackArray = new T[size];
        stackSize = size;
        top = -1;
    }

    // Destructor
    ~Stack() {
        delete[] stackArray;
    }

    // Stack operations
    void push(T value) {
        if (isFull()) {
            std::cout &lt;&lt; "Stack is full!" &lt;&lt; std::endl;
            return;
        }
        stackArray[++top] = value;
    }

    T pop() {
        if (isEmpty()) {
            std::cout &lt;&lt; "Stack is empty!" &lt;&lt; std::endl;
            return T(); // Return default value
        }
        return stackArray[top--];
    }

    T peek() const {
        if (isEmpty()) {
            std::cout &lt;&lt; "Stack is empty!" &lt;&lt; std::endl;
            return T();
        }
        return stackArray[top];
    }

    bool isEmpty() const {
        return top == -1;
    }

    bool isFull() const {
        return top == stackSize - 1;
    }
};

#endif</code></pre>
                </div>

                <div class="explanation">
                    <h4>Stack Operations Explained:</h4>
                    <ul>
                        <li><strong>Push:</strong> Add element to the top (like adding a plate to the stack)</li>
                        <li><strong>Pop:</strong> Remove element from the top (like taking a plate from the stack)</li>
                        <li><strong>Peek/Top:</strong> Look at the top element without removing it</li>
                        <li><strong>LIFO:</strong> Last In, First Out - the last element added is the first one removed</li>
                    </ul>
                </div>
            </div>

            <div class="code-example">
                <h3>Queue Implementation (FIFO)</h3>
                <p><strong>What it does:</strong> A queue is like a line at a store - first person in line is served first.</p>
                <p><strong>Why it's useful:</strong> Perfect for job scheduling, breadth-first search, and handling requests in order.</p>

                <div class="code-block">
                    <pre><code>// Queue.h - Template-based Queue
#ifndef QUEUE_H
#define QUEUE_H

template &lt;class T&gt;
class Queue {
private:
    T *queueArray;
    int queueSize;
    int front;
    int rear;
    int numItems;

public:
    // Constructor
    Queue(int size = 100) {
        queueArray = new T[size];
        queueSize = size;
        front = 0;
        rear = -1;
        numItems = 0;
    }

    // Destructor
    ~Queue() {
        delete[] queueArray;
    }

    // Queue operations
    void enqueue(T value) {
        if (isFull()) {
            std::cout &lt;&lt; "Queue is full!" &lt;&lt; std::endl;
            return;
        }
        rear = (rear + 1) % queueSize;
        queueArray[rear] = value;
        numItems++;
    }

    T dequeue() {
        if (isEmpty()) {
            std::cout &lt;&lt; "Queue is empty!" &lt;&lt; std::endl;
            return T();
        }
        T temp = queueArray[front];
        front = (front + 1) % queueSize;
        numItems--;
        return temp;
    }

    T peek() const {
        if (isEmpty()) {
            std::cout &lt;&lt; "Queue is empty!" &lt;&lt; std::endl;
            return T();
        }
        return queueArray[front];
    }

    bool isEmpty() const {
        return numItems == 0;
    }

    bool isFull() const {
        return numItems == queueSize;
    }
};

#endif</code></pre>
                </div>

                <div class="explanation">
                    <h4>Queue Operations Explained:</h4>
                    <ul>
                        <li><strong>Enqueue:</strong> Add element to the rear (back of the line)</li>
                        <li><strong>Dequeue:</strong> Remove element from the front (front of the line)</li>
                        <li><strong>Peek/Front:</strong> Look at the front element without removing it</li>
                        <li><strong>FIFO:</strong> First In, First Out - the first element added is the first one removed</li>
                        <li><strong>Circular:</strong> Uses modulo arithmetic to wrap around the array</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="expression-eval" class="code-section">
            <h2>🔢 Expression Evaluation (Week 17)</h2>
            <p class="section-intro">
                <strong>For Beginners:</strong> Think of expression evaluation like following a recipe. You need to follow the right order of operations,
                just like you can't put icing on a cake before baking it. We'll learn how computers handle mathematical expressions.
            </p>

            <div class="code-example">
                <h3>Infix to Postfix Converter</h3>
                <p><strong>What it does:</strong> Converts mathematical expressions from human-readable form (infix) to computer-friendly form (postfix).</p>
                <p><strong>Example:</strong> "2 + 3 * 4" (infix) becomes "2 3 4 * +" (postfix)</p>

                <div class="code-block">
                    <pre><code>// InfixToPostfix.h - Header file
#ifndef INFIX_TO_POSTFIX_H
#define INFIX_TO_POSTFIX_H

#include &lt;string&gt;

class InfixToPostfix {
private:
    std::string infixExpression;    // Original expression (e.g., "2+3*4")
    std::string postfixExpression;  // Converted expression (e.g., "23*4+")

public:
    // Constructor
    InfixToPostfix(std::string infix = "");

    // Main conversion method
    void convertToPostfix();

    // Helper methods
    bool hasHigherPrecedence(char op1, char op2);
    bool isOperator(char c);
    bool isOperand(char c);

    // Getters and setters
    void setInfix(std::string infix);
    std::string getInfix() const;
    std::string getPostfix() const;

    // Display methods
    void showInfix() const;
    void showPostfix() const;
};

#endif</code></pre>
                </div>

                <div class="explanation">
                    <h4>Understanding the Conversion:</h4>
                    <ul>
                        <li><strong>Infix:</strong> Normal math notation (2 + 3 * 4) - operators between operands</li>
                        <li><strong>Postfix:</strong> Operators after operands (2 3 4 * +) - easier for computers</li>
                        <li><strong>Precedence:</strong> * and / come before + and - (PEMDAS rules)</li>
                        <li><strong>Stack Usage:</strong> Temporary storage for operators during conversion</li>
                        <li><strong>Parentheses:</strong> Override normal precedence rules</li>
                    </ul>
                </div>
            </div>

            <div class="code-example">
                <h3>Postfix Expression Evaluator</h3>
                <p><strong>What it does:</strong> Evaluates postfix expressions using a stack-based approach.</p>
                <p><strong>Example:</strong> "23*4+" evaluates to (2*3)+4 = 10</p>

                <div class="code-block">
                    <pre><code>// PostfixEvaluator.h
#ifndef POSTFIX_EVALUATOR_H
#define POSTFIX_EVALUATOR_H

#include &lt;string&gt;
#include &lt;stack&gt;

class PostfixEvaluator {
private:
    std::string postfixExpression;
    double result;

public:
    // Constructor
    PostfixEvaluator(std::string postfix = "");

    // Main evaluation method
    double evaluate();

    // Helper methods
    bool isOperator(char c);
    double performOperation(char operation, double op1, double op2);

    // Getters and setters
    void setPostfix(std::string postfix);
    std::string getPostfix() const;
    double getResult() const;
};

#endif</code></pre>
                </div>

                <div class="code-block">
                    <pre><code>// PostfixEvaluator.cpp
#include "PostfixEvaluator.h"
#include &lt;iostream&gt;
#include &lt;cstdlib&gt;  // For atof()
#include &lt;cmath&gt;    // For pow()

// Constructor
PostfixEvaluator::PostfixEvaluator(std::string postfix) {
    postfixExpression = postfix;
    result = 0.0;
}

// Main evaluation method
double PostfixEvaluator::evaluate() {
    std::stack&lt;double&gt; operandStack;

    for (char ch : postfixExpression) {
        if (isdigit(ch)) {
            // Convert char digit to double and push
            operandStack.push(ch - '0');
        } else if (isOperator(ch)) {
            // Pop two operands
            if (operandStack.size() &lt; 2) {
                std::cout &lt;&lt; "Error: Insufficient operands" &lt;&lt; std::endl;
                return 0.0;
            }

            double op2 = operandStack.top(); operandStack.pop();
            double op1 = operandStack.top(); operandStack.pop();

            // Perform operation and push result
            double result = performOperation(ch, op1, op2);
            operandStack.push(result);
        }
    }

    if (operandStack.size() != 1) {
        std::cout &lt;&lt; "Error: Invalid expression" &lt;&lt; std::endl;
        return 0.0;
    }

    result = operandStack.top();
    return result;
}

// Check if character is operator
bool PostfixEvaluator::isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Perform arithmetic operation
double PostfixEvaluator::performOperation(char operation, double op1, double op2) {
    switch (operation) {
        case '+': return op1 + op2;
        case '-': return op1 - op2;
        case '*': return op1 * op2;
        case '/':
            if (op2 == 0) {
                std::cout &lt;&lt; "Error: Division by zero" &lt;&lt; std::endl;
                return 0.0;
            }
            return op1 / op2;
        case '^': return pow(op1, op2);
        default: return 0.0;
    }
}

// Getters and setters
void PostfixEvaluator::setPostfix(std::string postfix) {
    postfixExpression = postfix;
}

std::string PostfixEvaluator::getPostfix() const {
    return postfixExpression;
}

double PostfixEvaluator::getResult() const {
    return result;
}</code></pre>
                </div>

                <div class="explanation">
                    <h4>Postfix Evaluation Process:</h4>
                    <ul>
                        <li><strong>Operands:</strong> Push numbers directly to stack</li>
                        <li><strong>Operators:</strong> Pop two operands, perform operation, push result</li>
                        <li><strong>Final Result:</strong> Single value left in stack is the answer</li>
                        <li><strong>Error Handling:</strong> Check for insufficient operands and division by zero</li>
                        <li><strong>Order:</strong> Operands appear before operators they apply to</li>
                    </ul>
                </div>
            </div>

        <section id="inheritance" class="code-section">
            <h2>🏗️ Inheritance and Advanced Classes (Week 15)</h2>
            <p class="section-intro">
                <strong>For Beginners:</strong> Inheritance is like family relationships in programming. A child class can inherit traits from a parent class,
                just like you inherit characteristics from your parents. This saves code and creates logical hierarchies.
            </p>

            <div class="code-example">
                <h3>Person and Student Classes</h3>
                <p><strong>What it does:</strong> Demonstrates how a Student class can inherit properties from a Person class and add its own features.</p>

                <div class="code-block">
                    <pre><code>// Person.h - Base class
#ifndef PERSON_H
#define PERSON_H

#include &lt;string&gt;

class Person {
protected:  // Protected: accessible to derived classes
    std::string name;
    int age;
    std::string address;

public:
    // Constructor
    Person(std::string n = "", int a = 0, std::string addr = "");

    // Basic methods
    void setName(std::string n);
    void setAge(int a);
    void setAddress(std::string addr);

    std::string getName() const;
    int getAge() const;
    std::string getAddress() const;

    // Display information
    virtual void displayInfo() const;  // Virtual: can be overridden
};

#endif</code></pre>
                </div>

                <div class="code-block">
                    <pre><code>// Student.h - Derived class
#ifndef STUDENT_H
#define STUDENT_H

#include "Person.h"
#include &lt;vector&gt;

class Student : public Person {  // Inherits from Person
private:
    std::string studentID;
    std::string major;
    double gpa;
    std::vector&lt;std::string&gt; courses;  // List of enrolled courses

public:
    // Constructor
    Student(std::string n = "", int a = 0, std::string addr = "",
            std::string id = "", std::string maj = "", double g = 0.0);

    // Student-specific methods
    void setStudentID(std::string id);
    void setMajor(std::string maj);
    void setGPA(double g);
    void addCourse(std::string course);
    void removeCourse(std::string course);

    // Getters
    std::string getStudentID() const;
    std::string getMajor() const;
    double getGPA() const;
    std::vector&lt;std::string&gt; getCourses() const;

    // Override base class method
    void displayInfo() const override;
};

#endif</code></pre>
                </div>

                <div class="explanation">
                    <h4>Inheritance Benefits:</h4>
                    <ul>
                        <li><strong>Code Reuse:</strong> Student gets all Person properties without rewriting code</li>
                        <li><strong>Hierarchy:</strong> Creates logical relationships between classes</li>
                        <li><strong>Extensibility:</strong> Easy to add new types (Teacher, Staff) that inherit from Person</li>
                        <li><strong>Polymorphism:</strong> Objects can be treated as their base type but behave differently</li>
                    </ul>
                </div>
            </div>
        </section>

        <section id="advanced-topics" class="code-section">
            <h2>🚀 Advanced Topics</h2>
            <p class="section-intro">
                <strong>For Beginners:</strong> These are more complex concepts that build upon the basics. Don't worry if they seem challenging at first -
                they're like advanced cooking techniques that become easier with practice.
            </p>

            <div class="code-example">
                <h3>Template Classes (Week 21)</h3>
                <p><strong>What it does:</strong> Templates allow you to write generic code that works with any data type, like a universal container.</p>

                <div class="code-block">
                    <pre><code>// GenericStack.h - Template class
#ifndef GENERIC_STACK_H
#define GENERIC_STACK_H

template &lt;class T&gt;  // T can be any data type
class GenericStack {
private:
    T *stackArray;      // Array to hold stack elements
    int stackSize;      // Size of the stack
    int top;            // Index of top element

public:
    // Constructor
    GenericStack(int size = 10) {
        stackSize = size;
        stackArray = new T[stackSize];
        top = -1;  // Empty stack
    }

    // Destructor
    ~GenericStack() {
        delete[] stackArray;
    }

    // Stack operations
    void push(T value) {
        if (isFull()) {
            std::cout &lt;&lt; "Stack is full!" &lt;&lt; std::endl;
            return;
        }
        stackArray[++top] = value;
    }

    T pop() {
        if (isEmpty()) {
            std::cout &lt;&lt; "Stack is empty!" &lt;&lt; std::endl;
            return T();  // Return default value
        }
        return stackArray[top--];
    }

    T peek() const {
        if (isEmpty()) {
            std::cout &lt;&lt; "Stack is empty!" &lt;&lt; std::endl;
            return T();
        }
        return stackArray[top];
    }

    bool isEmpty() const {
        return top == -1;
    }

    bool isFull() const {
        return top == stackSize - 1;
    }
};

#endif</code></pre>
                </div>

                <div class="explanation">
                    <h4>Templates Explained:</h4>
                    <ul>
                        <li><strong>Generic Programming:</strong> Write code once, use with any data type (int, double, string, etc.)</li>
                        <li><strong>Type Safety:</strong> Compiler ensures type correctness at compile time</li>
                        <li><strong>Code Efficiency:</strong> No runtime type checking needed</li>
                        <li><strong>Flexibility:</strong> Same stack can hold integers, strings, or custom objects</li>
                    </ul>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <p>&copy; 2025 CSY2006 C++ Programming Course. Complete Code Library with Beginner-Friendly Explanations.</p>
    </footer>

    <script src="script.js"></script>
</body>
</html>
