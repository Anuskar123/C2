<!-- Week 18: Trees and Graphs -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 18: Trees and Graphs - CSY2006</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>CSY2006 C++ Programming Course Notes</h1>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="code-library.html">Code Library</a></li>
                <li><a href="mcqs.html">MCQs & Practice</a></li>
                <li><a href="week10.html">Week 10</a></li>
                <li><a href="week15.html">Week 15</a></li>
                <li><a href="week16.html">Week 16</a></li>
                <li><a href="week17.html">Week 17</a></li>
                <li><a href="week18.html">Week 18</a></li>
                <li><a href="week19.html">Week 19</a></li>
                <li><a href="week20.html">Week 20</a></li>
                <li><a href="week21.html">Week 21</a></li>
                <li><a href="week22.html">Week 22</a></li>
                <li><a href="week23.html">Week 23</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section class="week-header">
            <h2>Week 18: Trees and Graphs</h2>
            <p>Advanced Data Structures</p>
        </section>

        <div class="week-content">
            <div class="main-content">
                <section id="overview">
                    <h3>Week 18 Overview</h3>
                    <p>This week explores tree and graph data structures - powerful ways to represent hierarchical relationships and networks. Trees help organize data with parent-child relationships, while graphs model complex connections between entities.</p>

                    <div class="beginner-tip">
                        <h4>üß† Think Like a Beginner</h4>
                        <p><strong>Real-World Analogy:</strong> Trees are like family trees or organizational charts showing hierarchical relationships. Graphs are like social networks or road maps showing connections between places.</p>
                    </div>

                    <h4>Key Topics:</h4>
                    <ul>
                        <li><strong>Binary Trees:</strong> Each node has at most two children (like a tournament bracket)</li>
                        <li><strong>Binary Search Trees:</strong> Left child < parent < right child (for fast searching)</li>
                        <li><strong>Tree Traversals:</strong> Different ways to visit all nodes (inorder, preorder, postorder)</li>
                        <li><strong>Graph Representation:</strong> Adjacency lists vs matrices (like different ways to show friendships)</li>
                        <li><strong>Graph Traversal:</strong> DFS (deep first) vs BFS (breadth first) algorithms</li>
                    </ul>

                    <div class="important-note">
                        <h4>üí° Why Trees and Graphs Matter</h4>
                        <p>Trees and graphs are everywhere in computing - file systems are trees, social networks are graphs, compilers use trees to parse code, and GPS uses graphs for navigation!</p>
                    </div>
                </section>

                <section id="binary-tree">
                    <h3>Binary Tree Implementation</h3>
                    
                    <div class="beginner-tip">
                        <h4>üå≥ Binary Tree Analogy: Tournament Bracket</h4>
                        <p><strong>Simple Explanation:</strong> A binary tree is like a tournament bracket where each match has two teams competing, and winners advance to the next round. Each node (match) can have at most two children (two teams), just like a binary tree where each node has at most two child nodes.</p>
                    </div>

                    <h4>üèóÔ∏è Tree Terminology:</h4>
                    <ul>
                        <li><strong>Root:</strong> The topmost node (like the championship match)</li>
                        <li><strong>Parent/Child:</strong> Connected nodes where one is above (parent) and below (child)</li>
                        <li><strong>Leaf:</strong> A node with no children (like the first round matches)</li>
                        <li><strong>Height:</strong> Number of levels from root to deepest leaf</li>
                        <li><strong>Subtree:</strong> A tree formed by a node and all its descendants</li>
                    </ul>

                    <h4>üéØ Real-World Examples:</h4>
                    <ul>
                        <li><strong>Family Tree:</strong> Parents have children, who may have their own children</li>
                        <li><strong>File System:</strong> Folders contain files and subfolders</li>
                        <li><strong>Organization Chart:</strong> Managers have employees who may manage others</li>
                        <li><strong>Decision Trees:</strong> Each decision branches into possible outcomes</li>
                    </ul>

                    <div class="important-note">
                        <h4>‚ö†Ô∏è Binary Tree Rules</h4>
                        <p>Each node can have at most 2 children (left and right)<br>
                        No specific ordering required (unlike Binary Search Trees)</p>
                    </div>

                    <div class="code-block">
                        <pre>struct TreeNode {
    int data;
    TreeNode* left;
    TreeNode* right;

    TreeNode(int val) : data(val), left(NULL), right(NULL) {}
};

class BinaryTree {
private:
    TreeNode* root;

public:
    BinaryTree() : root(NULL) {}

    void insert(int val) {
        root = insertRecursive(root, val);
    }

    TreeNode* insertRecursive(TreeNode* node, int val) {
        if (node == NULL) {
            return new TreeNode(val);
        }

        if (val &lt; node-&gt;data) {
            node-&gt;left = insertRecursive(node-&gt;left, val);
        } else {
            node-&gt;right = insertRecursive(node-&gt;right, val);
        }

        return node;
    }

    void inorderTraversal(TreeNode* node) {
        if (node != NULL) {
            inorderTraversal(node-&gt;left);
            cout &lt;&lt; node-&gt;data &lt;&lt; " ";
            inorderTraversal(node-&gt;right);
        }
    }
};</pre>
                    </div>
                </section>

                <section id="qa-section">
                    <h3>Practice Questions & Answers (20 Questions)</h3>

                    <!-- Question 1: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 1: Find the error in this BST insertion:</h4>
                            <div class="code-block">
                                <pre>struct Node {
    int data;
    Node* left;
    Node* right;
};

Node* insert(Node* root, int value) {
    if (root == nullptr) {
        root = new Node();
        root-&gt;data = value;
        root-&gt;left = root-&gt;right = nullptr;
        return root;
    }
    
    if (value &lt; root-&gt;data) {
        root-&gt;left = insert(root-&gt;left, value);
    } else {
        root-&gt;right = insert(root-&gt;right, value);
    }
    
    return root;  // This is correct!
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>Actually, this code is correct!</strong></p>
                            <p><strong>Explanation:</strong> The insertion properly handles the recursive case and returns the updated root. The only potential issue would be memory allocation failure, but that's not shown here.</p>
                        </div>
                    </div>

                    <!-- Question 2: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 2: What will be the inorder traversal of this BST?</h4>
                            <div class="code-block">
                                <pre>// Insert sequence: 50, 30, 70, 20, 40, 60, 80
// What is the inorder traversal?</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Inorder:</strong> 20, 30, 40, 50, 60, 70, 80</p>
                            <p><strong>Explanation:</strong> BST inorder traversal always produces sorted order regardless of insertion sequence.</p>
                        </div>
                    </div>

                    <!-- Question 3: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 3: Complete the binary tree height function:</h4>
                            <div class="code-block">
                                <pre>int getHeight(Node* root) {
    if (root == nullptr) return 0;
    // Complete the recursive height calculation
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>int getHeight(Node* root) {
    if (root == nullptr) return 0;
    int leftHeight = getHeight(root-&gt;left);
    int rightHeight = getHeight(root-&gt;right);
    return 1 + max(leftHeight, rightHeight);
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Height is 1 + maximum of left and right subtree heights.</p>
                        </div>
                    </div>

                    <!-- Question 4: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 4: Write a function to count leaf nodes:</h4>
                            <div class="code-block">
                                <pre>struct Node {
    int data;
    Node* left;
    Node* right;
};

int countLeaves(Node* root) {
    // Write the implementation
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>int countLeaves(Node* root) {
    if (root == nullptr) return 0;
    if (root-&gt;left == nullptr && root-&gt;right == nullptr) return 1;
    return countLeaves(root-&gt;left) + countLeaves(root-&gt;right);
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> A leaf node has no children. Count leaves in left and right subtrees recursively.</p>
                        </div>
                    </div>

                    <!-- Question 5: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 5: Find the error in this graph adjacency list:</h4>
                            <div class="code-block">
                                <pre>class Graph {
private:
    vector&lt;vector&lt;int&gt;&gt; adjList;
    int vertices;
    
public:
    Graph(int v) : vertices(v), adjList(v) {}
    
    void addEdge(int u, int v) {
        adjList[u].push_back(v);
        // Missing reverse edge for undirected graph!
    }
};</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Missing reverse edge for undirected graph</p>
                            <p><strong>Explanation:</strong> For undirected graphs, edges go both ways, so we need <code>adjList[v].push_back(u)</code> too.</p>
                            <p><strong>Fix:</strong> Add <code>adjList[v].push_back(u);</code> for undirected graphs.</p>
                        </div>
                    </div>

                    <!-- Question 6: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 6: What will be the preorder traversal?</h4>
                            <div class="code-block">
                                <pre>// Tree structure:
//       1
//      / \
//     2   3
//    / \
//   4   5
//
// Preorder traversal:</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Preorder:</strong> 1, 2, 4, 5, 3</p>
                            <p><strong>Explanation:</strong> Preorder visits root, left subtree, right subtree.</p>
                        </div>
                    </div>

                    <!-- Question 7: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 7: Complete the BST search function:</h4>
                            <div class="code-block">
                                <pre>bool search(Node* root, int value) {
    // Complete the recursive search
    if (root == nullptr) return false;
    // Your code here
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>bool search(Node* root, int value) {
    if (root == nullptr) return false;
    if (root-&gt;data == value) return true;
    if (value &lt; root-&gt;data) return search(root-&gt;left, value);
    return search(root-&gt;right, value);
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Search left subtree if value is smaller, right subtree if larger.</p>
                        </div>
                    </div>

                    <!-- Question 8: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 8: Write a BFS traversal function:</h4>
                            <div class="code-block">
                                <pre>#include &lt;queue&gt;
#include &lt;vector&gt;

void BFS(vector&lt;vector&lt;int&gt;&gt;&amp; adj, int start) {
    vector&lt;bool&gt; visited(adj.size(), false);
    queue&lt;int&gt; q;
    // Write the BFS implementation
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>void BFS(vector&lt;vector&lt;int&gt;&gt;&amp; adj, int start) {
    vector&lt;bool&gt; visited(adj.size(), false);
    queue&lt;int&gt; q;
    
    visited[start] = true;
    q.push(start);
    
    while (!q.empty()) {
        int node = q.front(); q.pop();
        cout &lt;&lt; node &lt;&lt; " ";
        
        for (int neighbor : adj[node]) {
            if (!visited[neighbor]) {
                visited[neighbor] = true;
                q.push(neighbor);
            }
        }
    }
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Use queue to visit nodes level by level, mark visited to avoid cycles.</p>
                        </div>
                    </div>

                    <!-- Question 9: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 9: Find the error in this DFS implementation:</h4>
                            <div class="code-block">
                                <pre>void DFS(vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited, int node) {
    visited[node] = true;
    cout &lt;&lt; node &lt;&lt; " ";
    
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            DFS(adj, visited, neighbor);
        }
    }
}

// In main:
vector&lt;bool&gt; visited(V, false);
DFS(adj, visited, 0);  // What if graph has disconnected components?</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>Issue:</strong> Doesn't handle disconnected graphs</p>
                            <p><strong>Explanation:</strong> Single DFS call only visits connected component of start node.</p>
                            <p><strong>Fix:</strong> Call DFS for each unvisited node to handle all components.</p>
                        </div>
                    </div>

                    <!-- Question 10: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 10: What will be the postorder traversal?</h4>
                            <div class="code-block">
                                <pre>// Same tree as Question 6
//       1
//      / \
//     2   3
//    / \
//   4   5
//
// Postorder traversal:</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Postorder:</strong> 4, 5, 2, 3, 1</p>
                            <p><strong>Explanation:</strong> Postorder visits left subtree, right subtree, then root.</p>
                        </div>
                    </div>

                    <!-- Question 11: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 11: Complete the binary tree mirror function:</h4>
                            <div class="code-block">
                                <pre>void mirror(Node* root) {
    if (root == nullptr) return;
    // Complete the mirror operation
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>void mirror(Node* root) {
    if (root == nullptr) return;
    
    // Swap left and right subtrees
    Node* temp = root-&gt;left;
    root-&gt;left = root-&gt;right;
    root-&gt;right = temp;
    
    // Recursively mirror subtrees
    mirror(root-&gt;left);
    mirror(root-&gt;right);
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Swap left and right children, then recursively mirror both subtrees.</p>
                        </div>
                    </div>

                    <!-- Question 12: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 12: Write a function to check if tree is balanced:</h4>
                            <div class="code-block">
                                <pre>bool isBalanced(Node* root) {
    // Write the balanced tree check
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>bool isBalanced(Node* root) {
    if (root == nullptr) return true;
    
    int leftHeight = getHeight(root-&gt;left);
    int rightHeight = getHeight(root-&gt;right);
    
    if (abs(leftHeight - rightHeight) &lt;= 1 && 
        isBalanced(root-&gt;left) && 
        isBalanced(root-&gt;right)) {
        return true;
    }
    
    return false;
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> A tree is balanced if height difference between subtrees ‚â§ 1 and both subtrees are balanced.</p>
                        </div>
                    </div>

                    <!-- Question 13: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 13: Find the error in this tree deletion:</h4>
                            <div class="code-block">
                                <pre>Node* deleteNode(Node* root, int value) {
    if (root == nullptr) return root;
    
    if (value &lt; root-&gt;data) {
        root-&gt;left = deleteNode(root-&gt;left, value);
    } else if (value &gt; root-&gt;data) {
        root-&gt;right = deleteNode(root-&gt;right, value);
    } else {
        // Node to be deleted found
        if (root-&gt;left == nullptr) {
            Node* temp = root-&gt;right;
            delete root;
            return temp;
        } else if (root-&gt;right == nullptr) {
            Node* temp = root-&gt;left;
            delete root;
            return temp;
        }
        
        // Node with two children - find inorder successor
        Node* temp = findMin(root-&gt;right);
        root-&gt;data = temp-&gt;data;
        root-&gt;right = deleteNode(root-&gt;right, temp-&gt;data);
    }
    return root;
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>This code is actually correct!</strong></p>
                            <p><strong>Explanation:</strong> The deletion properly handles all three cases: no children, one child, and two children using inorder successor.</p>
                        </div>
                    </div>

                    <!-- Question 14: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 14: What will be the BFS traversal order?</h4>
                            <div class="code-block">
                                <pre>// Graph adjacency list:
// 0: 1, 2
// 1: 0, 3, 4  
// 2: 0, 4
// 3: 1
// 4: 1, 2
//
// BFS starting from node 0:</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>BFS:</strong> 0, 1, 2, 3, 4</p>
                            <p><strong>Explanation:</strong> Level 0: 0, Level 1: 1, 2, Level 2: 3, 4</p>
                        </div>
                    </div>

                    <!-- Question 15: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 15: Complete the graph cycle detection:</h4>
                            <div class="code-block">
                                <pre>bool hasCycleDFS(vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;bool&gt;&amp; visited, 
                               vector&lt;bool&gt;&amp; recStack, int node) {
    visited[node] = true;
    recStack[node] = true;
    
    for (int neighbor : adj[node]) {
        // Complete the cycle detection logic
    }
    
    recStack[node] = false;
    return false;
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>        if (!visited[neighbor]) {
            if (hasCycleDFS(adj, visited, recStack, neighbor)) {
                return true;
            }
        } else if (recStack[neighbor]) {
            return true; // Cycle detected
        }</pre>
                            </div>
                            <p><strong>Explanation:</strong> If neighbor is visited and in recursion stack, there's a back edge (cycle).</p>
                        </div>
                    </div>

                    <!-- Question 16: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 16: Write a function to find tree diameter:</h4>
                            <div class="code-block">
                                <pre>pair&lt;int, int&gt; diameterHelper(Node* root) {
    // Returns {height, diameter}
    if (root == nullptr) return {0, 0};
    
    auto left = diameterHelper(root-&gt;left);
    auto right = diameterHelper(root-&gt;right);
    
    int height = 1 + max(left.first, right.first);
    int diameter = max({left.second, right.second, 
                       left.first + right.first});
    
    return {height, diameter};
}

int getDiameter(Node* root) {
    return diameterHelper(root).second;
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>The code is already complete!</strong></p>
                            <p><strong>Explanation:</strong> Diameter is the longest path between any two nodes. It can be through root or in subtrees.</p>
                        </div>
                    </div>

                    <!-- Question 17: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 17: Find the error in this tree construction:</h4>
                            <div class="code-block">
                                <pre>// Attempting to build BST from array [1, 2, 3, 4, 5]
Node* buildBST(vector&lt;int&gt;&amp; arr, int start, int end) {
    if (start &gt; end) return nullptr;
    
    int mid = (start + end) / 2;
    Node* root = new Node(arr[mid]);
    
    root-&gt;left = buildBST(arr, start, mid - 1);
    root-&gt;right = buildBST(arr, mid + 1, end);  // Error!
    
    return root;
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>This code is correct for building a balanced BST!</strong></p>
                            <p><strong>Explanation:</strong> Using middle element as root creates a balanced BST from sorted array.</p>
                        </div>
                    </div>

                    <!-- Question 18: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 18: What will be the DFS traversal order?</h4>
                            <div class="code-block">
                                <pre>// Same graph as Question 14
// DFS starting from node 0:</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>DFS:</strong> 0, 1, 3, 4, 2</p>
                            <p><strong>Explanation:</strong> Explores deep before backtracking: 0‚Üí1‚Üí3, then 1‚Üí4, then back to 0‚Üí2.</p>
                        </div>
                    </div>

                    <!-- Question 19: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 19: Complete the lowest common ancestor (LCA):</h4>
                            <div class="code-block">
                                <pre>Node* findLCA(Node* root, int n1, int n2) {
    if (root == nullptr) return nullptr;
    
    // Complete the LCA logic for BST
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>Node* findLCA(Node* root, int n1, int n2) {
    if (root == nullptr) return nullptr;
    
    // If both n1 and n2 are smaller than root, LCA is in left subtree
    if (root-&gt;data > n1 && root-&gt;data > n2) {
        return findLCA(root-&gt;left, n1, n2);
    }
    
    // If both n1 and n2 are greater than root, LCA is in right subtree
    if (root-&gt;data &lt; n1 && root-&gt;data &lt; n2) {
        return findLCA(root-&gt;right, n1, n2);
    }
    
    // Root is LCA
    return root;
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> In BST, LCA is the node where paths to n1 and n2 diverge.</p>
                        </div>
                    </div>

                    <!-- Question 20: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 20: Write a function to check if binary tree is BST:</h4>
                            <div class="code-block">
                                <pre>bool isBST(Node* root, int min = INT_MIN, int max = INT_MAX) {
    // Write the BST validation
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>bool isBST(Node* root, int min, int max) {
    if (root == nullptr) return true;
    
    if (root-&gt;data &lt;= min || root-&gt;data &gt;= max) return false;
    
    return isBST(root-&gt;left, min, root-&gt;data) && 
           isBST(root-&gt;right, root-&gt;data, max);
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Each node must be within valid range (greater than left subtree max, less than right subtree min).</p>
                        </div>
                    </div>
                </section>

                <section id="exceptions-templates">
                    <h3>Exceptions and Templates Practice Questions</h3>

                    <!-- Question 21: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 21: What will be the output of this exception example?</h4>
                            <div class="code-block">
                                <pre>double divide(int numerator, int denominator) {
    if (denominator == 0) {
        throw string("ERROR: Cannot divide by zero.\n");
    }
    return static_cast&lt;double&gt;(numerator) / denominator;
}

int main() {
    try {
        cout &lt;&lt; "Result: " &lt;&lt; divide(10, 0) &lt;&lt; endl;
    }
    catch (string exceptionString) {
        cout &lt;&lt; exceptionString;
    }
    cout &lt;&lt; "End of the program.\n";
    return 0;
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Output:</strong></p>
                            <pre>ERROR: Cannot divide by zero.
End of the program.</pre>
                            <p><strong>Explanation:</strong> When division by zero occurs, the exception is thrown and caught by the catch block. Program continues after handling the exception.</p>
                        </div>
                    </div>

                    <!-- Question 22: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 22: Complete the Rectangle class with exception handling:</h4>
                            <div class="code-block">
                                <pre>class Rectangle {
private:
    double width, length;
public:
    class NegativeSize { };
    
    Rectangle() { width = 0.0; length = 0.0; }
    
    void setWidth(double w) {
        // Complete with exception handling
    }
    
    void setLength(double len) {
        // Complete with exception handling
    }
    
    double getArea() const { return width * length; }
};</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>    void setWidth(double w) {
        if (w &gt;= 0)
            width = w;
        else
            throw NegativeSize();
    }
    
    void setLength(double len) {
        if (len &gt;= 0)
            length = len;
        else
            throw NegativeSize();
    }</pre>
                            </div>
                            <p><strong>Explanation:</strong> Check for negative values and throw custom exception class if invalid dimensions are provided.</p>
                        </div>
                    </div>

                    <!-- Question 23: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 23: Write a function with multiple exception types:</h4>
                            <div class="code-block">
                                <pre>class Calculator {
public:
    class DivideByZero { };
    class InvalidOperation { };
    
    double divide(double a, double b) {
        // Complete with exception handling
    }
    
    double sqrt(double x) {
        // Complete with exception handling
    }
};</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>    double divide(double a, double b) {
        if (b == 0) {
            throw DivideByZero();
        }
        return a / b;
    }
    
    double sqrt(double x) {
        if (x &lt; 0) {
            throw InvalidOperation();
        }
        return std::sqrt(x);
    }</pre>
                            </div>
                            <p><strong>Explanation:</strong> Different exception types allow specific error handling for different error conditions.</p>
                        </div>
                    </div>

                    <!-- Question 24: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 24: Find the error in this exception handling:</h4>
                            <div class="code-block">
                                <pre>try {
    int* arr = new int[10];
    // Some code that might throw
    delete[] arr;
}
catch(...) {
    cout &lt;&lt; "Error occurred" &lt;&lt; endl;
    // Memory leak! arr not deleted if exception thrown
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Memory leak - dynamically allocated memory not freed if exception occurs</p>
                            <p><strong>Explanation:</strong> When an exception is thrown, the code after the exception point is skipped, including cleanup code.</p>
                            <p><strong>Fix:</strong> Use RAII (Resource Acquisition Is Initialization) or smart pointers, or put cleanup in catch block.</p>
                        </div>
                    </div>

                    <!-- Question 25: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 25: What will be the output of this exception propagation?</h4>
                            <div class="code-block">
                                <pre>void func3() {
    throw runtime_error("Error in func3");
}

void func2() {
    func3();
}

void func1() {
    try {
        func2();
    }
    catch (const runtime_error&amp; e) {
        cout &lt;&lt; "Caught: " &lt;&lt; e.what() &lt;&lt; endl;
    }
}

int main() {
    func1();
    cout &lt;&lt; "Program continues" &lt;&lt; endl;
    return 0;
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Output:</strong></p>
                            <pre>Caught: Error in func3
Program continues</pre>
                            <p><strong>Explanation:</strong> Exceptions propagate up the call stack until caught. The program continues after the exception is handled.</p>
                        </div>
                    </div>

                    <!-- Question 26: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 26: Complete the template class SimpleVector:</h4>
                            <div class="code-block">
                                <pre>template &lt;class T&gt;
class SimpleVector {
private:
    T* array;
    int size;
public:
    SimpleVector(int s) {
        // Complete constructor
    }
    
    ~SimpleVector() {
        // Complete destructor
    }
    
    T&amp; operator[](int index) {
        // Complete with bounds checking
    }
};</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>    SimpleVector(int s) {
        size = s;
        array = new T[size];
    }
    
    ~SimpleVector() {
        delete[] array;
    }
    
    T&amp; operator[](int index) {
        if (index &lt; 0 || index &gt;= size) {
            throw out_of_range("Index out of bounds");
        }
        return array[index];
    }</pre>
                            </div>
                            <p><strong>Explanation:</strong> Template class that can work with any data type, with proper memory management and bounds checking.</p>
                        </div>
                    </div>

                    <!-- Question 27: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 27: Write a template function to find maximum:</h4>
                            <div class="code-block">
                                <pre>template &lt;typename T&gt;
T findMax(T arr[], int size) {
    // Complete the template function
}

int main() {
    int intArr[] = {1, 5, 3, 9, 2};
    double doubleArr[] = {1.1, 5.5, 3.3, 9.9, 2.2};
    
    cout &lt;&lt; findMax(intArr, 5) &lt;&lt; endl;
    cout &lt;&lt; findMax(doubleArr, 5) &lt;&lt; endl;
    return 0;
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>template &lt;typename T&gt;
T findMax(T arr[], int size) {
    if (size &lt;= 0) {
        throw invalid_argument("Array size must be positive");
    }
    
    T maxVal = arr[0];
    for (int i = 1; i &lt; size; i++) {
        if (arr[i] &gt; maxVal) {
            maxVal = arr[i];
        }
    }
    return maxVal;
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Generic function that works with any comparable type, includes error checking for empty arrays.</p>
                        </div>
                    </div>

                    <!-- Question 28: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 28: Find the error in this template usage:</h4>
                            <div class="code-block">
                                <pre>template &lt;typename T&gt;
class Stack {
private:
    T* data;
    int capacity;
    int top;
public:
    Stack(int cap) {
        capacity = cap;
        data = new T[capacity];
        top = -1;
    }
    
    void push(T item) {
        if (top &gt;= capacity - 1) {
            throw overflow_error("Stack overflow");
        }
        data[++top] = item;
    }
    
    T pop() {
        if (top &lt; 0) {
            throw underflow_error("Stack underflow");
        }
        return data[top--];
    }
};

int main() {
    Stack&lt;int&gt; s(5);
    s.push(1);
    s.push(2);
    cout &lt;&lt; s.pop() &lt;&lt; endl;
    cout &lt;&lt; s.pop() &lt;&lt; endl;
    cout &lt;&lt; s.pop() &lt;&lt; endl;  // Error!
    return 0;
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Attempting to pop from empty stack</p>
                            <p><strong>Explanation:</strong> After popping 2 elements, the stack is empty. Third pop() will throw underflow_error.</p>
                            <p><strong>Fix:</strong> Check if stack is empty before popping, or handle the exception.</p>
                        </div>
                    </div>

                    <!-- Question 29: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 29: What will be the output of this template specialization?</h4>
                            <div class="code-block">
                                <pre>template &lt;typename T&gt;
void printType(T value) {
    cout &lt;&lt; "Generic type" &lt;&lt; endl;
}

template &lt;&gt;
void printType&lt;int&gt;(int value) {
    cout &lt;&lt; "Integer: " &lt;&lt; value &lt;&lt; endl;
}

template &lt;&gt;
void printType&lt;double&gt;(double value) {
    cout &lt;&lt; "Double: " &lt;&lt; value &lt;&lt; endl;
}

int main() {
    printType(5);
    printType(3.14);
    printType("hello");
    return 0;
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Output:</strong></p>
                            <pre>Integer: 5
Double: 3.14
Generic type</pre>
                            <p><strong>Explanation:</strong> Template specialization allows different behavior for specific types. Generic version used for types without specialization.</p>
                        </div>
                    </div>

                    <!-- Question 30: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 30: Complete the exception-safe template class:</h4>
                            <div class="code-block">
                                <pre>template &lt;typename T&gt;
class SafeArray {
private:
    T* data;
    size_t size;
public:
    SafeArray(size_t s) : size(s) {
        // Complete with exception safety
    }
    
    ~SafeArray() {
        // Complete destructor
    }
    
    T&amp; at(size_t index) {
        // Complete with bounds checking
    }
    
    SafeArray(const SafeArray&amp; other) {
        // Complete copy constructor
    }
    
    SafeArray&amp; operator=(const SafeArray&amp; other) {
        // Complete assignment operator
    }
};</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>    SafeArray(size_t s) : size(s) {
        if (s == 0) {
            throw invalid_argument("Size must be positive");
        }
        data = new T[size];
    }
    
    ~SafeArray() {
        delete[] data;
    }
    
    T&amp; at(size_t index) {
        if (index &gt;= size) {
            throw out_of_range("Index out of bounds");
        }
        return data[index];
    }
    
    SafeArray(const SafeArray&amp; other) : size(other.size) {
        data = new T[size];
        for (size_t i = 0; i &lt; size; i++) {
            data[i] = other.data[i];
        }
    }
    
    SafeArray&amp; operator=(const SafeArray&amp; other) {
        if (this != &amp;other) {
            delete[] data;
            size = other.size;
            data = new T[size];
            for (size_t i = 0; i &lt; size; i++) {
                data[i] = other.data[i];
            }
        }
        return *this;
    }</pre>
                            </div>
                            <p><strong>Explanation:</strong> Exception-safe template with proper resource management, bounds checking, and copy semantics.</p>
                        </div>
                    </div>
                </section>
            </div>

            <div class="sidebar">
                <h3>Navigation</h3>
                <ul>
                    <li><a href="#overview">Overview</a></li>
                    <li><a href="#binary-tree">Binary Tree</a></li>
                    <li><a href="#qa-section">Q&A (20)</a></li>
                    <li><a href="#exceptions-templates">Exceptions & Templates</a></li>
                </ul>
            </div>
        </div>
    </main>

    <footer>
        <p>&copy; 2025 CSY2006 C++ Programming Course. All rights reserved.</p>
    </footer>

    <script src="script.js"></script>
</body>
</html>
