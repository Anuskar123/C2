<!-- Week 19: Advanced Algorithms -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Week 19: Advanced Algorithms - CSY2006</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>CSY2006 C++ Programming Course Notes</h1>
        <nav>
            <ul>
                <li><a href="index.html">Home</a></li>
                <li><a href="code-library.html">Code Library</a></li>
                <li><a href="mcqs.html">MCQs & Practice</a></li>
                <li><a href="week10.html">Week 10</a></li>
                <li><a href="week15.html">Week 15</a></li>
                <li><a href="week16.html">Week 16</a></li>
                <li><a href="week17.html">Week 17</a></li>
                <li><a href="week18.html">Week 18</a></li>
                <li><a href="week19.html">Week 19</a></li>
                <li><a href="week20.html">Week 20</a></li>
                <li><a href="week21.html">Week 21</a></li>
                <li><a href="week22.html">Week 22</a></li>
                <li><a href="week23.html">Week 23</a></li>
            </ul>
        </nav>
    </header>

    <main>
        <section class="week-header">
            <h2>Week 19: Advanced Algorithms</h2>
            <p>Sorting, Searching, and Optimization</p>
        </section>

        <div class="week-content">
            <div class="main-content">
                <section id="overview">
                    <h3>Week 19 Overview</h3>
                    <p>This week explores efficient algorithms for sorting and searching data. These algorithms are the backbone of computer science and determine how fast your programs can organize and find information.</p>

                    <div class="beginner-tip">
                        <h4>üß† Think Like a Beginner</h4>
                        <p><strong>Real-World Analogy:</strong> Sorting algorithms are like different ways to organize your bookshelf. Some methods are fast but use more memory, others are slower but more memory-efficient. Searching is like finding a specific book in your organized (or unorganized) collection.</p>
                    </div>

                    <h4>Key Topics:</h4>
                    <ul>
                        <li><strong>Sorting algorithms:</strong> QuickSort (fast divide-and-conquer), MergeSort (stable and efficient), HeapSort (memory efficient)</li>
                        <li><strong>Searching algorithms:</strong> Binary Search (lightning fast on sorted data), Hashing (constant time lookups)</li>
                        <li><strong>Algorithm complexity:</strong> Big O notation - measuring how algorithm performance scales</li>
                        <li><strong>Divide and conquer:</strong> Breaking problems into smaller, solvable pieces</li>
                        <li><strong>Optimization techniques:</strong> Making algorithms faster and more efficient</li>
                    </ul>

                    <div class="important-note">
                        <h4>üí° Why Algorithm Efficiency Matters</h4>
                        <p>Choosing the right algorithm can mean the difference between a program that runs in seconds versus one that takes hours or days! Understanding Big O helps you make smart choices.</p>
                    </div>
                </section>

                <section id="sorting">
                    <h3>Sorting Algorithms</h3>
                    
                    <div class="beginner-tip">
                        <h4>üìö Sorting Analogy: Organizing Books on a Shelf</h4>
                        <p><strong>Simple Explanation:</strong> Sorting is like organizing books on a shelf by different criteria (author, title, height). Different sorting algorithms use different strategies, just like you might organize books differently based on your priorities and available space.</p>
                    </div>

                    <h4>üèóÔ∏è Common Sorting Algorithms:</h4>
                    <div class="comparison-table">
                        <div class="comparison-item">
                            <h5>‚ö° QuickSort (Fast but Unstable)</h5>
                            <ul>
                                <li>Uses a "pivot" element to divide the array</li>
                                <li>Very fast on average: O(n log n)</li>
                                <li>Worst case can be O(n¬≤) if pivot is bad</li>
                                <li>Not stable (equal elements may change order)</li>
                            </ul>
                        </div>
                        <div class="comparison-item">
                            <h5>üîÄ MergeSort (Stable and Predictable)</h5>
                            <ul>
                                <li>Divides array into halves, sorts each half</li>
                                <li>Always O(n log n) - very predictable</li>
                                <li>Stable (preserves order of equal elements)</li>
                                <li>Uses extra memory for merging</li>
                            </ul>
                        </div>
                        <div class="comparison-item">
                            <h5>üèóÔ∏è HeapSort (Memory Efficient)</h5>
                            <ul>
                                <li>Uses a binary heap data structure</li>
                                <li>O(n log n) and works in-place</li>
                                <li>Not stable but very memory efficient</li>
                                <li>Good when memory is limited</li>
                            </ul>
                        </div>
                    </div>

                    <h4>üéØ Real-World Examples:</h4>
                    <ul>
                        <li><strong>E-commerce:</strong> Sorting products by price, rating, or popularity</li>
                        <li><strong>Search Results:</strong> Ranking results by relevance score</li>
                        <li><strong>File Managers:</strong> Sorting files by name, size, or date</li>
                        <li><strong>Leaderboards:</strong> Ranking players by score</li>
                    </ul>

                    <h4>QuickSort Implementation</h4>
                    <div class="code-block">
                        <pre>int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j &lt; high; j++) {
        if (arr[j] &lt; pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}

void quickSort(int arr[], int low, int high) {
    if (low &lt; high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}</pre>
                    </div>

                    <h4>Binary Search</h4>
                    
                    <div class="beginner-tip">
                        <h4>üîç Binary Search Analogy: Finding a Word in a Dictionary</h4>
                        <p><strong>Simple Explanation:</strong> Binary search is like looking up a word in a dictionary. Instead of checking every page, you open to the middle, see if your word comes before or after, then repeat with just half the remaining pages. This eliminates half the possibilities with each check!</p>
                    </div>

                    <h4>üéØ Binary Search Requirements:</h4>
                    <ul>
                        <li>Data must be sorted first</li>
                        <li>Works on arrays or similar structures</li>
                        <li>Extremely fast: O(log n) time complexity</li>
                        <li>Compared to linear search O(n), this is much faster for large datasets</li>
                    </ul>

                    <div class="important-note">
                        <h4>‚ö†Ô∏è The Key Insight</h4>
                        <p>Binary search eliminates half the search space with each comparison. A list of 1 million items takes at most 20 comparisons to find any item (2¬≤‚Å∞ = 1,048,576)!</p>
                    </div>
                    <div class="code-block">
                        <pre>int binarySearch(int arr[], int left, int right, int target) {
    while (left &lt;= right) {
        int mid = left + (right - left) / 2;

        if (arr[mid] == target)
            return mid;

        if (arr[mid] &lt; target)
            left = mid + 1;
        else
            right = mid - 1;
    }
    return -1; // Not found
}</pre>
                    </div>
                </section>

                <section id="qa-section">
                    <h3>Practice Questions & Answers (20 Questions)</h3>

                    <!-- Question 1: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 1: Find the error in this QuickSort partition:</h4>
                            <div class="code-block">
                                <pre>int partition(int arr[], int low, int high) {
    int pivot = arr[low];  // Using first element as pivot
    int i = low;
    int j = high;
    
    while (i &lt; j) {
        while (arr[i] &lt;= pivot) i++;
        while (arr[j] &gt; pivot) j--;
        
        if (i &lt; j) {
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[low], arr[j]);  // Error in pivot placement!
    return j;
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Incorrect pivot placement</p>
                            <p><strong>Explanation:</strong> Should swap <code>arr[low]</code> with <code>arr[j]</code>, but the logic assumes pivot is at <code>arr[low]</code>.</p>
                            <p><strong>Fix:</strong> The swap should be <code>swap(arr[low], arr[j]);</code> which is already correct in this code.</p>
                        </div>
                    </div>

                    <!-- Question 2: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 2: What will be the time complexity of this algorithm?</h4>
                            <div class="code-block">
                                <pre>void algorithm(int n) {
    for(int i = 0; i &lt; n; i++) {
        for(int j = i; j &lt; n; j++) {
            cout &lt;&lt; "Hello";
        }
    }
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Time Complexity:</strong> O(n¬≤)</p>
                            <p><strong>Explanation:</strong> Outer loop runs n times, inner loop runs n-i times on average n/2 times, so total is O(n¬≤).</p>
                        </div>
                    </div>

                    <!-- Question 3: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 3: Complete the MergeSort implementation:</h4>
                            <div class="code-block">
                                <pre>void merge(int arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;
    
    int* L = new int[n1];
    int* R = new int[n2];
    
    // Complete copying elements to temp arrays
    // Your code here
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>    for(int i = 0; i &lt; n1; i++)
        L[i] = arr[left + i];
    for(int j = 0; j &lt; n2; j++)
        R[j] = arr[mid + 1 + j];
    
    // Then merge back...</pre>
                            </div>
                            <p><strong>Explanation:</strong> Copy left half to L array, right half to R array for merging.</p>
                        </div>
                    </div>

                    <!-- Question 4: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 4: Write a function to find the median of two sorted arrays:</h4>
                            <div class="code-block">
                                <pre>double findMedian(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
    // Write the implementation using binary search approach
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>double findMedian(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {
    if (nums1.size() > nums2.size()) swap(nums1, nums2);
    
    int m = nums1.size(), n = nums2.size();
    int total = m + n;
    int half = (total + 1) / 2;
    
    int left = 0, right = m;
    while (left &lt;= right) {
        int i = (left + right) / 2;
        int j = half - i;
        
        int nums1Left = (i > 0) ? nums1[i-1] : INT_MIN;
        int nums1Right = (i &lt; m) ? nums1[i] : INT_MAX;
        int nums2Left = (j > 0) ? nums2[j-1] : INT_MIN;
        int nums2Right = (j &lt; n) ? nums2[j] : INT_MAX;
        
        if (nums1Left &lt;= nums2Right && nums2Left &lt;= nums1Right) {
            if (total % 2 == 1) return max(nums1Left, nums2Left);
            return (max(nums1Left, nums2Left) + min(nums1Right, nums2Right)) / 2.0;
        } else if (nums1Left > nums2Right) {
            right = i - 1;
        } else {
            left = i + 1;
        }
    }
    return 0;
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Uses binary search to partition arrays such that elements on left are ‚â§ elements on right.</p>
                        </div>
                    </div>

                    <!-- Question 5: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 5: Find the error in this binary search for first occurrence:</h4>
                            <div class="code-block">
                                <pre>int findFirstOccurrence(vector&lt;int&gt;&amp; arr, int target) {
    int left = 0, right = arr.size() - 1;
    int result = -1;
    
    while (left &lt;= right) {
        int mid = left + (right - left) / 2;
        
        if (arr[mid] == target) {
            result = mid;
            right = mid - 1;  // Search left half
        } else if (arr[mid] &lt; target) {
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return result;
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>This code is correct!</strong></p>
                            <p><strong>Explanation:</strong> When target is found, it continues searching left half to find the first occurrence.</p>
                        </div>
                    </div>

                    <!-- Question 6: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 6: What will be the space complexity of this recursive algorithm?</h4>
                            <div class="code-block">
                                <pre>int fibonacci(int n) {
    if (n &lt;= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Space Complexity:</strong> O(n)</p>
                            <p><strong>Explanation:</strong> Maximum recursion depth is n, so O(n) stack space is used.</p>
                        </div>
                    </div>

                    <!-- Question 7: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 7: Complete the heapify function for HeapSort:</h4>
                            <div class="code-block">
                                <pre>void heapify(int arr[], int n, int i) {
    int largest = i;
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    
    // Complete the heapify logic
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>    if (left &lt; n && arr[left] > arr[largest])
        largest = left;
    
    if (right &lt; n && arr[right] > arr[largest])
        largest = right;
    
    if (largest != i) {
        swap(arr[i], arr[largest]);
        heapify(arr, n, largest);
    }</pre>
                            </div>
                            <p><strong>Explanation:</strong> Find largest among root, left, right children, swap if needed, and recursively heapify.</p>
                        </div>
                    </div>

                    <!-- Question 8: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 8: Write a function to find the kth largest element:</h4>
                            <div class="code-block">
                                <pre>int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
    // Write using QuickSelect algorithm
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>int findKthLargest(vector&lt;int&gt;&amp; nums, int k) {
    int left = 0, right = nums.size() - 1;
    
    while (left &lt;= right) {
        int pivotIndex = partition(nums, left, right);
        
        if (pivotIndex == nums.size() - k) {
            return nums[pivotIndex];
        } else if (pivotIndex &lt; nums.size() - k) {
            left = pivotIndex + 1;
        } else {
            right = pivotIndex - 1;
        }
    }
    return -1;
}

int partition(vector&lt;int&gt;&amp; nums, int left, int right) {
    int pivot = nums[right];
    int i = left;
    
    for (int j = left; j &lt; right; j++) {
        if (nums[j] &lt;= pivot) {
            swap(nums[i], nums[j]);
            i++;
        }
    }
    swap(nums[i], nums[right]);
    return i;
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> QuickSelect finds kth element in average O(n) time using partitioning.</p>
                        </div>
                    </div>

                    <!-- Question 9: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 9: Find the error in this complexity analysis:</h4>
                            <div class="code-block">
                                <pre>// Algorithm: Find maximum element in array
int findMax(int arr[], int n) {
    int max = arr[0];
    for(int i = 1; i &lt; n; i++) {
        if(arr[i] > max) max = arr[i];
    }
    return max;
}

// Someone claims: "This algorithm has O(log n) time complexity"
// Is this correct?</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Incorrect complexity claim</p>
                            <p><strong>Explanation:</strong> The algorithm scans through all n elements, so it's O(n), not O(log n).</p>
                            <p><strong>Correction:</strong> O(log n) would be for algorithms like binary search that divide the problem size.</p>
                        </div>
                    </div>

                    <!-- Question 10: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 10: What will be the best case time complexity of QuickSort?</h4>
                        </div>
                        <div class="answer">
                            <p><strong>Best Case:</strong> O(n log n)</p>
                            <p><strong>Explanation:</strong> Occurs when pivot divides array into roughly equal halves at each step.</p>
                        </div>
                    </div>

                    <!-- Question 11: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 11: Complete the interpolation search:</h4>
                            <div class="code-block">
                                <pre>int interpolationSearch(int arr[], int n, int target) {
    int low = 0, high = n - 1;
    
    while (low &lt;= high && target &gt;= arr[low] && target &lt;= arr[high]) {
        // Complete the position calculation
        int pos = low + ((target - arr[low]) * (high - low)) / (arr[high] - arr[low]);
        
        if (arr[pos] == target) return pos;
        // Complete the search logic
    }
    return -1;
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>        if (arr[pos] == target) return pos;
        else if (arr[pos] &lt; target) low = pos + 1;
        else high = pos - 1;</pre>
                            </div>
                            <p><strong>Explanation:</strong> If target is greater, search right half; if smaller, search left half.</p>
                        </div>
                    </div>

                    <!-- Question 12: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 12: Write a function to count inversions in an array:</h4>
                            <div class="code-block">
                                <pre>// Inversion: i &lt; j but arr[i] > arr[j]
long long countInversions(vector&lt;int&gt;&amp; arr) {
    // Write using merge sort approach
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>long long merge(vector&lt;int&gt;&amp; arr, int left, int mid, int right) {
    vector&lt;int&gt; temp(right - left + 1);
    int i = left, j = mid + 1, k = 0;
    long long inv_count = 0;
    
    while (i &lt;= mid && j &lt;= right) {
        if (arr[i] &lt;= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            inv_count += (mid - i + 1); // All remaining left elements are greater
        }
    }
    
    while (i &lt;= mid) temp[k++] = arr[i++];
    while (j &lt;= right) temp[k++] = arr[j++];
    
    for (int p = 0; p &lt; k; p++) {
        arr[left + p] = temp[p];
    }
    
    return inv_count;
}

long long _mergeSort(vector&lt;int&gt;&amp; arr, int left, int right) {
    long long inv_count = 0;
    if (left &lt; right) {
        int mid = left + (right - left) / 2;
        inv_count += _mergeSort(arr, left, mid);
        inv_count += _mergeSort(arr, mid + 1, right);
        inv_count += merge(arr, left, mid, right);
    }
    return inv_count;
}

long long countInversions(vector&lt;int&gt;&amp; arr) {
    return _mergeSort(arr, 0, arr.size() - 1);
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Modified merge sort counts inversions during the merge step.</p>
                        </div>
                    </div>

                    <!-- Question 13: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 13: Find the error in this dynamic programming solution:</h4>
                            <div class="code-block">
                                <pre>// Longest Increasing Subsequence
int LIS(vector&lt;int&gt;&amp; nums) {
    int n = nums.size();
    vector&lt;int&gt; dp(n, 1);
    
    for(int i = 1; i &lt; n; i++) {
        for(int j = 0; j &lt; i; j++) {
            if(nums[i] > nums[j]) {
                dp[i] = max(dp[i], dp[j] + 1);
            }
        }
    }
    
    return *max_element(dp.begin(), dp.end());
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>This code is correct!</strong></p>
                            <p><strong>Explanation:</strong> This is the standard O(n¬≤) dynamic programming solution for LIS.</p>
                        </div>
                    </div>

                    <!-- Question 14: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 14: What will be the time complexity of this nested loop?</h4>
                            <div class="code-block">
                                <pre>for(int i = 0; i &lt; n; i++) {
    for(int j = i + 1; j &lt; n; j++) {
        for(int k = j + 1; k &lt; n; k++) {
            // O(1) operation
        }
    }
}</pre>
                            </div>
                            <span class="question-type">Type: Find the Output</span>
                        </div>
                        <div class="answer">
                            <p><strong>Time Complexity:</strong> O(n¬≥)</p>
                            <p><strong>Explanation:</strong> Three nested loops: i from 0 to n-1, j from i+1 to n-1, k from j+1 to n-1.</p>
                        </div>
                    </div>

                    <!-- Question 15: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 15: Complete the Rabin-Karp string matching:</h4>
                            <div class="code-block">
                                <pre>vector&lt;int&gt; rabinKarp(string text, string pattern) {
    vector&lt;int&gt; result;
    int n = text.size(), m = pattern.size();
    int d = 256; // Number of characters
    int q = 101; // Prime number
    
    // Complete the algorithm
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>    int h = 1;
    for (int i = 0; i &lt; m - 1; i++)
        h = (h * d) % q;
    
    int p = 0, t = 0;
    for (int i = 0; i &lt; m; i++) {
        p = (d * p + pattern[i]) % q;
        t = (d * t + text[i]) % q;
    }
    
    for (int i = 0; i &lt;= n - m; i++) {
        if (p == t) {
            bool match = true;
            for (int j = 0; j &lt; m; j++) {
                if (text[i + j] != pattern[j]) {
                    match = false;
                    break;
                }
            }
            if (match) result.push_back(i);
        }
        
        if (i &lt; n - m) {
            t = (d * (t - text[i] * h) + text[i + m]) % q;
            if (t &lt; 0) t += q;
        }
    }
    
    return result;</pre>
                            </div>
                            <p><strong>Explanation:</strong> Rolling hash technique for efficient string pattern matching.</p>
                        </div>
                    </div>

                    <!-- Question 16: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 16: Write a function to find the maximum subarray sum:</h4>
                            <div class="code-block">
                                <pre>// Kadane's Algorithm
int maxSubarraySum(vector&lt;int&gt;&amp; nums) {
    // Write the implementation
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-block">
                                <pre>int maxSubarraySum(vector&lt;int&gt;&amp; nums) {
    int max_so_far = INT_MIN;
    int max_ending_here = 0;
    
    for (int i = 0; i &lt; nums.size(); i++) {
        max_ending_here += nums[i];
        
        if (max_so_far &lt; max_ending_here) {
            max_so_far = max_ending_here;
        }
        
        if (max_ending_here &lt; 0) {
            max_ending_here = 0;
        }
    }
    
    return max_so_far;
}</pre>
                            </div>
                            <p><strong>Explanation:</strong> Kadane's algorithm finds maximum contiguous subarray sum in O(n) time.</p>
                        </div>
                    </div>

                    <!-- Question 17: Find the Error -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 17: Find the error in this hash table implementation:</h4>
                            <div class="code-block">
                                <pre>class HashTable {
private:
    vector&lt;string&gt; table;
    int size;
    
public:
    HashTable(int s) : size(s), table(s) {}
    
    int hashFunction(string key) {
        int hash = 0;
        for(char c : key) {
            hash += c;
        }
        return hash % size;  // Linear probing?
    }
    
    void insert(string key) {
        int index = hashFunction(key);
        while (!table[index].empty()) {
            index = (index + 1) % size;  // Linear probing
        }
        table[index] = key;
    }
};</pre>
                            </div>
                            <span class="question-type">Type: Find the Error</span>
                        </div>
                        <div class="answer">
                            <p><strong>Issue:</strong> No handling of table full condition</p>
                            <p><strong>Explanation:</strong> If table becomes full, the while loop will infinite loop. Need to check if we've probed all positions.</p>
                            <p><strong>Fix:</strong> Add a counter to detect when table is full.</p>
                        </div>
                    </div>

                    <!-- Question 18: Find the Output -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 18: What will be the worst case time complexity of QuickSort?</h4>
                        </div>
                        <div class="answer">
                            <p><strong>Worst Case:</strong> O(n¬≤)</p>
                            <p><strong>Explanation:</strong> Occurs when pivot is always the smallest or largest element, leading to unbalanced partitions.</p>
                        </div>
                    </div>

                    <!-- Question 19: Complete the Code -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 19: Complete the Floyd-Warshall algorithm:</h4>
                            <div class="code-block">
                                <pre>void floydWarshall(vector&lt;vector&lt;int&gt;&gt;&amp; dist, int V) {
    // Complete the all-pairs shortest path algorithm
    for(int k = 0; k &lt; V; k++) {
        for(int i = 0; i &lt; V; i++) {
            for(int j = 0; j &lt; V; j++) {
                // Complete the relaxation step
            }
        }
    }
}</pre>
                            </div>
                            <span class="question-type">Type: Complete the Code</span>
                        </div>
                        <div class="answer">
                            <p><strong>Completed Code:</strong></p>
                            <div class="code-block">
                                <pre>                if (dist[i][k] != INT_MAX && dist[k][j] != INT_MAX && 
                    dist[i][k] + dist[k][j] &lt; dist[i][j]) {
                    dist[i][j] = dist[i][k] + dist[k][j];
                }</pre>
                            </div>
                            <p><strong>Explanation:</strong> If path through k is shorter than direct path, update distance.</p>
                        </div>
                    </div>

                    <!-- Question 20: Write a Function -->
                    <div class="qa-section">
                        <div class="question" tabindex="0">
                            <h4>Question 20: Write a function to find the longest common subsequence:</h4>
                            <div class="code-block">
                                <pre>string LCS(string text1, string text2) {
    int m = text1.size(), n = text2.size();
    vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
    
    // Fill DP table
    for(int i = 1; i &lt;= m; i++) {
        for(int j = 1; j &lt;= n; j++) {
            if(text1[i-1] == text2[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
            } else {
                dp[i][j] = max(dp[i-1][j], dp[i][j-1]);
            }
        }
    }
    
    // Reconstruct LCS
    string lcs = "";
    int i = m, j = n;
    while(i > 0 && j > 0) {
        if(text1[i-1] == text2[j-1]) {
            lcs = text1[i-1] + lcs;
            i--; j--;
        } else if(dp[i-1][j] > dp[i][j-1]) {
            i--;
        } else {
            j--;
        }
    }
    return lcs;
}</pre>
                            </div>
                            <span class="question-type">Type: Write a Function</span>
                        </div>
                        <div class="answer">
                            <p><strong>The code is already complete!</strong></p>
                            <p><strong>Explanation:</strong> Dynamic programming solution that finds LCS by comparing characters and building the result backwards.</p>
                        </div>
                    </div>
                </section>
            </div>

            <div class="sidebar">
                <h3>Navigation</h3>
                <ul>
                    <li><a href="#overview">Overview</a></li>
                    <li><a href="#sorting">Sorting</a></li>
                    <li><a href="#qa-section">Q&A</a></li>
                </ul>
            </div>
        </div>
    </main>

    <footer>
        <p>&copy; 2025 CSY2006 C++ Programming Course. All rights reserved.</p>
    </footer>

    <script src="script.js"></script>
</body>
</html>
