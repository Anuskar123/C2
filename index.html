<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>C++ Programming Notes - CSY2006</title>
    <link rel="stylesheet" href="style.css">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
</head>
<body>
    <header>
        <div class="container">
            <h1><i class="fas fa-code"></i> C++ Programming Notes</h1>
            <p>CSY2006 - Software Engineering 2</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul>
                <li><a href="#week10" onclick="showWeek('week10')">Week 10 - Classes</a></li>
                <li><a href="#week15" onclick="showWeek('week15')">Week 15 - Operators</a></li>
                <li><a href="#week16" onclick="showWeek('week16')">Week 16 - Inheritance</a></li>
                <li><a href="#week17" onclick="showWeek('week17')">Week 17 - Polymorphism</a></li>
                <li><a href="#week18" onclick="showWeek('week18')">Week 18 - Templates</a></li>
                <li><a href="#week19" onclick="showWeek('week19')">Week 19 - Linked Lists</a></li>
                <li><a href="#week20" onclick="showWeek('week20')">Week 20 - Stacks & Queues</a></li>
                <li><a href="#quiz" onclick="showQuiz()">Interactive Quiz</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <!-- Week 10 Content -->
        <section id="week10" class="week-content active">
            <h2><i class="fas fa-cube"></i> Week 10 - Introduction to Classes</h2>
            
            <!-- Notes Section -->
            <div class="notes-section">
                <h3><i class="fas fa-book"></i> Detailed Notes</h3>
                
                <div class="concept-card">
                    <h4>What is Object-Oriented Programming?</h4>
                    <p>Object-oriented programming (OOP) is a programming paradigm that organizes code around objects rather than functions. It's like thinking about real-world entities and modeling them in code.</p>
                    
                    <h5>Why OOP over Procedural Programming?</h5>
                    <ul>
                        <li><strong>Modularity:</strong> Code is organized into separate, manageable units</li>
                        <li><strong>Reusability:</strong> Objects can be reused in different programs</li>
                        <li><strong>Maintainability:</strong> Changes to one part don't affect other parts</li>
                        <li><strong>Scalability:</strong> Easier to build large, complex programs</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <h4>Core OOP Concepts</h4>
                    <div class="concept-item">
                        <h5>1. Class</h5>
                        <p>A class is like a blueprint or template. Just like a house blueprint shows how to build a house, a class shows how to create objects.</p>
                        <div class="code-container">
                            <pre><code class="language-cpp">class Student {
    // Blueprint for creating student objects
};</code></pre>
                        </div>
                    </div>

                    <div class="concept-item">
                        <h5>2. Object</h5>
                        <p>An object is an instance of a class. If class is the blueprint, object is the actual house built from that blueprint.</p>
                        <div class="code-container">
                            <pre><code class="language-cpp">Student john;     // john is an object of Student class
Student mary;     // mary is another object of Student class</code></pre>
                        </div>
                    </div>

                    <div class="concept-item">
                        <h5>3. Encapsulation</h5>
                        <p>Bundling data (variables) and methods (functions) that work on that data into a single unit (class).</p>
                    </div>

                    <div class="concept-item">
                        <h5>4. Data Hiding</h5>
                        <p>Making data members private so they can't be accessed directly from outside the class. This protects data from accidental modification.</p>
                    </div>
                </div>

                <div class="concept-card">
                    <h4>Access Specifiers</h4>
                    <table class="access-table">
                        <tr>
                            <th>Specifier</th>
                            <th>Access Level</th>
                            <th>Use Case</th>
                        </tr>
                        <tr>
                            <td><code>private</code></td>
                            <td>Only within the same class</td>
                            <td>Data members, internal helper functions</td>
                        </tr>
                        <tr>
                            <td><code>public</code></td>
                            <td>Accessible from anywhere</td>
                            <td>Interface functions, constructors</td>
                        </tr>
                        <tr>
                            <td><code>protected</code></td>
                            <td>Same class and derived classes</td>
                            <td>Inheritance scenarios</td>
                        </tr>
                    </table>
                </div>

                <div class="concept-card">
                    <h4>Constructors and Destructors</h4>
                    
                    <h5>Constructor</h5>
                    <p>Special function that automatically runs when an object is created. Used to initialize object data.</p>
                    <ul>
                        <li>Same name as class</li>
                        <li>No return type</li>
                        <li>Can be overloaded</li>
                    </ul>

                    <h5>Destructor</h5>
                    <p>Special function that automatically runs when an object is destroyed. Used to clean up resources.</p>
                    <ul>
                        <li>Same name as class with ~ prefix</li>
                        <li>No return type, no parameters</li>
                        <li>Only one per class</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <h4>Static Members</h4>
                    <p><strong>Static variables:</strong> Shared among all objects of a class. Only one copy exists regardless of how many objects are created.</p>
                    <p><strong>Static functions:</strong> Can be called without creating an object. Can only access static variables.</p>
                </div>
            </div>

            <!-- Questions Section -->
            <div class="questions-section">
                <h3><i class="fas fa-question-circle"></i> Week 10 Practice Questions</h3>

                <!-- MCQ Questions -->
                <div class="question-category">
                    <h4>Multiple Choice Questions</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q1.</span>
                            <span class="question-type mcq">MCQ</span>
                        </div>
                        <p><strong>Which access specifier should be used for data members to implement data hiding?</strong></p>
                        <div class="mcq-options">
                            <div class="option">A) public</div>
                            <div class="option">B) private</div>
                            <div class="option">C) protected</div>
                            <div class="option">D) static</div>
                        </div>
                        <div class="answer">
                            <p><strong>Answer: B) private</strong></p>
                            <p><strong>Explanation:</strong> Data hiding is achieved by making data members private. This prevents direct access from outside the class, ensuring data integrity and security. Public members can be accessed from anywhere, which breaks encapsulation.</p>
                        </div>
                    </div>

                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q2.</span>
                            <span class="question-type mcq">MCQ</span>
                        </div>
                        <p><strong>What is the default access specifier for class members in C++?</strong></p>
                        <div class="mcq-options">
                            <div class="option">A) public</div>
                            <div class="option">B) private</div>
                            <div class="option">C) protected</div>
                            <div class="option">D) default</div>
                        </div>
                        <div class="answer">
                            <p><strong>Answer: B) private</strong></p>
                            <p><strong>Explanation:</strong> In C++ classes, if no access specifier is mentioned, members are private by default. This is different from structures where members are public by default.</p>
                        </div>
                    </div>
                </div>

                <!-- Find the Error Questions -->
                <div class="question-category">
                    <h4>Find the Error</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q3.</span>
                            <span class="question-type error">Find Error</span>
                        </div>
                        <p><strong>Find the error in this Circle class definition:</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">class Circle {
    double radius;
    const double PI = 3.14159;  // Error here
public:
    Circle() { radius = 0.0; }
    double getArea() { return PI * radius * radius; }
};</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Cannot initialize const member PI inside class declaration.</p>
                            <p><strong>Correction:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">class Circle {
    double radius;
    static const double PI;  // Declare as static const
public:
    Circle() { radius = 0.0; }
    double getArea() { return PI * radius * radius; }
};

// Define outside class
const double Circle::PI = 3.14159;</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Const members must be initialized in the constructor's initialization list or declared as static const and defined outside the class.</p>
                        </div>
                    </div>

                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q4.</span>
                            <span class="question-type error">Find Error</span>
                        </div>
                        <p><strong>What's wrong with this constructor?</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">class Car {
private:
    string make;
    int year;
public:
    void Car(string m, int y) {  // Error here
        make = m;
        year = y;
    }
};</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Constructor cannot have a return type (not even void).</p>
                            <p><strong>Correction:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">class Car {
private:
    string make;
    int year;
public:
    Car(string m, int y) {  // No return type
        make = m;
        year = y;
    }
};</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Constructors are special functions that don't have return types. They automatically return the object being constructed.</p>
                        </div>
                    </div>
                </div>

                <!-- Find Output Questions -->
                <div class="question-category">
                    <h4>Find the Output</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q5.</span>
                            <span class="question-type output">Find Output</span>
                        </div>
                        <p><strong>What will be the output of this code?</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Counter {
private:
    static int count;
public:
    Counter() { count++; }
    static int getCount() { return count; }
};

int Counter::count = 0;

int main() {
    Counter c1, c2, c3;
    cout << Counter::getCount() << endl;
    Counter c4;
    cout << Counter::getCount() << endl;
    return 0;
}</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Output:</strong></p>
                            <pre>3
4</pre>
                            <p><strong>Explanation:</strong> The static variable 'count' is shared among all Counter objects. Each time a Counter object is created, the constructor increments count. After creating c1, c2, c3: count = 3. After creating c4: count = 4.</p>
                        </div>
                    </div>
                </div>

                <!-- Complete the Code Questions -->
                <div class="question-category">
                    <h4>Complete the Code</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q6.</span>
                            <span class="question-type complete">Complete Code</span>
                        </div>
                        <p><strong>Complete the BankAccount class with automatic account number assignment:</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">class BankAccount {
private:
    string holderName;
    int accountNumber;
    string accountType;
    double balance;
    double interestRate;
    _________ int nextAccountNumber;  // Fill blank 1

public:
    BankAccount(string name, string type, double initialBalance, double rate) {
        holderName = name;
        accountType = type;
        balance = initialBalance;
        interestRate = rate;
        accountNumber = __________;  // Fill blank 2
        __________;  // Fill blank 3 (increment counter)
    }
    
    _________ int getNextAccountNumber() {  // Fill blank 4
        return nextAccountNumber;
    }
};</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Complete Code:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">class BankAccount {
private:
    string holderName;
    int accountNumber;
    string accountType;
    double balance;
    double interestRate;
    static int nextAccountNumber;  // Blank 1: static

public:
    BankAccount(string name, string type, double initialBalance, double rate) {
        holderName = name;
        accountType = type;
        balance = initialBalance;
        interestRate = rate;
        accountNumber = nextAccountNumber;  // Blank 2: nextAccountNumber
        nextAccountNumber++;  // Blank 3: nextAccountNumber++
    }
    
    static int getNextAccountNumber() {  // Blank 4: static
        return nextAccountNumber;
    }
};

// Don't forget to define the static member outside class
int BankAccount::nextAccountNumber = 1000;</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Static members are shared among all objects. nextAccountNumber keeps track of the next available account number, automatically incrementing for each new account.</p>
                        </div>
                    </div>
                </div>

                <!-- Lab Exercise Questions -->
                <div class="question-category">
                    <h4>Lab Exercise Questions</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q7.</span>
                            <span class="question-type lab">Lab Exercise</span>
                        </div>
                        <p><strong>Design a class that has an array of floating-point numbers. The constructor should accept an integer argument and dynamically allocate the array to hold that many numbers.</strong></p>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class FloatArray {
private:
    double* numbers;
    int size;

public:
    // Constructor - dynamically allocates array
    FloatArray(int arraySize) {
        size = arraySize;
        numbers = new double[size];
        // Initialize all elements to 0
        for (int i = 0; i < size; i++) {
            numbers[i] = 0.0;
        }
    }
    
    // Destructor - frees allocated memory
    ~FloatArray() {
        delete[] numbers;
    }
    
    // Store a number at given index
    void setNumber(int index, double value) {
        if (index >= 0 && index < size) {
            numbers[index] = value;
        } else {
            cout << "Index out of bounds!" << endl;
        }
    }
    
    // Retrieve a number from given index
    double getNumber(int index) const {
        if (index >= 0 && index < size) {
            return numbers[index];
        } else {
            cout << "Index out of bounds!" << endl;
            return 0.0;
        }
    }
    
    // Get array size
    int getSize() const {
        return size;
    }
    
    // Display all numbers
    void display() const {
        cout << "Array contents: ";
        for (int i = 0; i < size; i++) {
            cout << numbers[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    FloatArray arr(5);
    
    // Store some numbers
    arr.setNumber(0, 3.14);
    arr.setNumber(1, 2.71);
    arr.setNumber(2, 1.41);
    
    // Display array
    arr.display();
    
    // Retrieve and display individual numbers
    cout << "Element at index 1: " << arr.getNumber(1) << endl;
    
    return 0;
}</code></pre>
                            </div>
                            <p><strong>Key Points:</strong></p>
                            <ul>
                                <li><strong>Dynamic allocation:</strong> Using 'new' to allocate memory at runtime</li>
                                <li><strong>Destructor:</strong> Essential to prevent memory leaks by using 'delete[]'</li>
                                <li><strong>Bounds checking:</strong> Prevents array access errors</li>
                                <li><strong>Encapsulation:</strong> Array and size are private, accessed through public methods</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 1: Circle Class</h3>
                <div class="code-container">
                    <h4>Circle.h (Header File)</h4>
                    <pre><code class="language-cpp">#ifndef CIRCLE_H
#define CIRCLE_H

class Circle {
private:
    double radius;
    static const double PI;

public:
    // Constructors
    Circle();                    // Default constructor
    Circle(double r);           // Parameterized constructor
    
    // Mutator and Accessor methods
    void setRadius(double r);
    double getRadius() const;
    
    // Calculation methods
    double getArea() const;
    double getDiameter() const;
    double getCircumference() const;
};

#endif</code></pre>
                </div>

                <div class="code-container">
                    <h4>Circle.cpp (Implementation File)</h4>
                    <pre><code class="language-cpp">#include "Circle.h"
#include &lt;iostream&gt;

const double Circle::PI = 3.14159;

// Default constructor
Circle::Circle() {
    radius = 0.0;
}

// Parameterized constructor
Circle::Circle(double r) {
    setRadius(r);
}

// Mutator method
void Circle::setRadius(double r) {
    if (r >= 0) {
        radius = r;
    } else {
        radius = 0.0;
    }
}

// Accessor method
double Circle::getRadius() const {
    return radius;
}

// Calculate area
double Circle::getArea() const {
    return PI * radius * radius;
}

// Calculate diameter
double Circle::getDiameter() const {
    return radius * 2;
}

// Calculate circumference
double Circle::getCircumference() const {
    return 2 * PI * radius;
}</code></pre>
                </div>

                <div class="code-container">
                    <h4>Main Program</h4>
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include "Circle.h"
using namespace std;

int main() {
    double userRadius;
    
    cout << "Enter the radius of the circle: ";
    cin >> userRadius;
    
    Circle myCircle(userRadius);
    
    cout << "\nCircle Properties:" << endl;
    cout << "Radius: " << myCircle.getRadius() << endl;
    cout << "Area: " << myCircle.getArea() << endl;
    cout << "Diameter: " << myCircle.getDiameter() << endl;
    cout << "Circumference: " << myCircle.getCircumference() << endl;
    
    return 0;
}</code></pre>
                </div>

                <div class="output-container">
                    <h4>Sample Output</h4>
                    <pre>Enter the radius of the circle: 5

Circle Properties:
Radius: 5
Area: 78.5397
Diameter: 10
Circumference: 31.4159</pre>
                </div>

                <div class="question-card">
                    <h4>Practice Questions</h4>
                    <div class="question" onclick="toggleAnswer(this)">
                        <p><strong>Q1:</strong> What happens if we don't use const in the getRadius() method?</p>
                        <div class="answer">
                            <p><strong>Answer:</strong> The method will still work, but it's considered bad practice. The const keyword indicates that the method doesn't modify the object's state, making the code more readable and allowing the method to be called on const objects.</p>
                        </div>
                    </div>
                    
                    <div class="question" onclick="toggleAnswer(this)">
                        <p><strong>Q2:</strong> Complete the code: What's missing in this class declaration?</p>
                        <pre><code>class Rectangle {
    double width, height;
    // What's missing here?
public:
    Rectangle(double w, double h);
    double getArea();
};</code></pre>
                        <div class="answer">
                            <p><strong>Answer:</strong> Missing "private:" access specifier. While members are private by default, it's good practice to explicitly state it.</p>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 2: Car Class</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Car {
private:
    int yearModel;
    string make;
    int speed;

public:
    // Constructor
    Car(int year, string carMake) {
        yearModel = year;
        make = carMake;
        speed = 0;
    }
    
    // Accessors
    int getYearModel() const { return yearModel; }
    string getMake() const { return make; }
    int getSpeed() const { return speed; }
    
    // Methods to modify speed
    void accelerate() { speed += 5; }
    void brake() { 
        speed -= 5;
        if (speed < 0) speed = 0;  // Prevent negative speed
    }
};

int main() {
    Car myCar(2023, "Toyota");
    
    cout << "Car: " << myCar.getMake() << " " << myCar.getYearModel() << endl;
    cout << "Initial speed: " << myCar.getSpeed() << endl;
    
    // Accelerate 5 times
    for (int i = 0; i < 5; i++) {
        myCar.accelerate();
        cout << "After acceleration " << (i+1) << ": " << myCar.getSpeed() << " mph" << endl;
    }
    
    // Brake 5 times
    for (int i = 0; i < 5; i++) {
        myCar.brake();
        cout << "After braking " << (i+1) << ": " << myCar.getSpeed() << " mph" << endl;
    }
    
    return 0;
}</code></pre>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 3: PayRoll Class</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class PayRoll {
private:
    double hourlyPayRate;
    double hoursWorked;
    double totalPay;

public:
    // Constructor
    PayRoll(double payRate = 0.0) {
        hourlyPayRate = payRate;
        hoursWorked = 0.0;
        totalPay = 0.0;
    }
    
    // Mutators
    void setHourlyPayRate(double rate) {
        hourlyPayRate = (rate >= 0) ? rate : 0;
    }
    
    void setHoursWorked(double hours) {
        if (hours >= 0 && hours <= 60) {
            hoursWorked = hours;
            calculatePay();
        } else {
            cout << "Invalid hours! Must be between 0 and 60." << endl;
        }
    }
    
    // Accessors
    double getHourlyPayRate() const { return hourlyPayRate; }
    double getHoursWorked() const { return hoursWorked; }
    double getTotalPay() const { return totalPay; }
    
private:
    void calculatePay() {
        totalPay = hourlyPayRate * hoursWorked;
    }
};

int main() {
    const int NUM_EMPLOYEES = 7;
    PayRoll employees[NUM_EMPLOYEES];
    
    // Get pay rates and hours for each employee
    for (int i = 0; i < NUM_EMPLOYEES; i++) {
        double rate, hours;
        
        cout << "\nEmployee " << (i + 1) << ":" << endl;
        cout << "Enter hourly pay rate: $";
        cin >> rate;
        employees[i].setHourlyPayRate(rate);
        
        cout << "Enter hours worked (max 60): ";
        cin >> hours;
        employees[i].setHoursWorked(hours);
    }
    
    // Display results
    cout << "\n" << setw(10) << "Employee" << setw(12) << "Pay Rate" 
         << setw(12) << "Hours" << setw(12) << "Gross Pay" << endl;
    cout << string(46, '-') << endl;
    
    for (int i = 0; i < NUM_EMPLOYEES; i++) {
        cout << setw(10) << (i + 1) 
             << setw(12) << fixed << setprecision(2) << employees[i].getHourlyPayRate()
             << setw(12) << employees[i].getHoursWorked()
             << setw(12) << employees[i].getTotalPay() << endl;
    }
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Week 15 Content -->
        <section id="week15" class="week-content">
            <h2><i class="fas fa-plus-circle"></i> Week 15 - Operator Overloading</h2>
            
            <!-- Notes Section -->
            <div class="notes-section">
                <h3><i class="fas fa-book"></i> Detailed Notes</h3>
                
                <div class="concept-card">
                    <h4>What is Operator Overloading?</h4>
                    <p>Operator overloading allows you to give additional meanings to operators when used with objects of your class. It's like teaching C++ how to add, subtract, or compare your custom objects.</p>
                    
                    <h5>Why Use Operator Overloading?</h5>
                    <ul>
                        <li><strong>Natural syntax:</strong> Write <code>obj1 + obj2</code> instead of <code>obj1.add(obj2)</code></li>
                        <li><strong>Readability:</strong> Code becomes more intuitive and easier to understand</li>
                        <li><strong>Consistency:</strong> Objects behave like built-in types</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <h4>Overloadable Operators</h4>
                    <div class="operator-grid">
                        <div class="operator-category">
                            <h5>Arithmetic Operators</h5>
                            <code>+ - * / % ++ --</code>
                        </div>
                        <div class="operator-category">
                            <h5>Comparison Operators</h5>
                            <code>== != < > <= >=</code>
                        </div>
                        <div class="operator-category">
                            <h5>Assignment Operators</h5>
                            <code>= += -= *= /= %=</code>
                        </div>
                        <div class="operator-category">
                            <h5>Other Operators</h5>
                            <code>[] () -> << >></code>
                        </div>
                    </div>
                    
                    <h5>Non-Overloadable Operators</h5>
                    <code>. :: ?: sizeof .*</code>
                </div>

                <div class="concept-card">
                    <h4>Copy Constructor</h4>
                    <p>A special constructor that creates a new object as a copy of an existing object.</p>
                    
                    <h5>When is Copy Constructor Called?</h5>
                    <ul>
                        <li>When an object is initialized with another object: <code>Student s2 = s1;</code></li>
                        <li>When an object is passed by value to a function</li>
                        <li>When an object is returned by value from a function</li>
                    </ul>

                    <h5>Deep vs Shallow Copy</h5>
                    <table class="copy-table">
                        <tr>
                            <th>Shallow Copy</th>
                            <th>Deep Copy</th>
                        </tr>
                        <tr>
                            <td>Copies memory addresses</td>
                            <td>Copies actual data</td>
                        </tr>
                        <tr>
                            <td>Objects share same memory</td>
                            <td>Objects have separate memory</td>
                        </tr>
                        <tr>
                            <td>Default copy constructor</td>
                            <td>Custom copy constructor needed</td>
                        </tr>
                    </table>
                </div>

                <div class="concept-card">
                    <h4>Const Correctness</h4>
                    <p>Using <code>const</code> appropriately to prevent unintended modifications.</p>
                    
                    <h5>Types of const usage:</h5>
                    <ul>
                        <li><strong>const parameters:</strong> <code>void func(const Object& obj)</code></li>
                        <li><strong>const member functions:</strong> <code>int getValue() const</code></li>
                        <li><strong>const objects:</strong> <code>const Object obj;</code></li>
                    </ul>
                </div>
            </div>

            <!-- Questions Section -->
            <div class="questions-section">
                <h3><i class="fas fa-question-circle"></i> Week 15 Practice Questions</h3>

                <!-- MCQ Questions -->
                <div class="question-category">
                    <h4>Multiple Choice Questions</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q1.</span>
                            <span class="question-type mcq">MCQ</span>
                        </div>
                        <p><strong>Which operator cannot be overloaded in C++?</strong></p>
                        <div class="mcq-options">
                            <div class="option">A) +</div>
                            <div class="option">B) []</div>
                            <div class="option">C) ::</div>
                            <div class="option">D) ==</div>
                        </div>
                        <div class="answer">
                            <p><strong>Answer: C) ::</strong></p>
                            <p><strong>Explanation:</strong> The scope resolution operator (::) cannot be overloaded. Other non-overloadable operators include ., .*, ?:, and sizeof. These operators have special meaning in C++ and their behavior cannot be changed.</p>
                        </div>
                    </div>

                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q2.</span>
                            <span class="question-type mcq">MCQ</span>
                        </div>
                        <p><strong>What is the correct syntax for overloading the + operator?</strong></p>
                        <div class="mcq-options">
                            <div class="option">A) Time operator+(Time& other)</div>
                            <div class="option">B) Time operator+(const Time& other) const</div>
                            <div class="option">C) operator+(const Time& other)</div>
                            <div class="option">D) Time +(const Time& other)</div>
                        </div>
                        <div class="answer">
                            <p><strong>Answer: B) Time operator+(const Time& other) const</strong></p>
                            <p><strong>Explanation:</strong> The correct syntax includes return type (Time), operator keyword, operator symbol (+), const reference parameter, and const function qualifier since addition doesn't modify the original object.</p>
                        </div>
                    </div>
                </div>

                <!-- Find the Error Questions -->
                <div class="question-category">
                    <h4>Find the Error</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q3.</span>
                            <span class="question-type error">Find Error</span>
                        </div>
                        <p><strong>Find the error in this operator overloading:</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">class Time {
private:
    int hours, minutes;
public:
    Time operator+(Time other) {  // Error here
        Time result;
        result.minutes = minutes + other.minutes;
        result.hours = hours + other.hours;
        if (result.minutes >= 60) {
            result.hours++;
            result.minutes -= 60;
        }
        return result;
    }
};</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Parameter should be const reference and function should be const.</p>
                            <p><strong>Correction:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">Time operator+(const Time& other) const {
    // Pass by const reference to avoid unnecessary copying
    // Function is const because it doesn't modify the object
    Time result;
    result.minutes = minutes + other.minutes;
    result.hours = hours + other.hours;
    if (result.minutes >= 60) {
        result.hours++;
        result.minutes -= 60;
    }
    return result;
}</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Using const reference parameter avoids unnecessary copying and prevents modification of the parameter. The const function qualifier indicates the method doesn't change the object's state.</p>
                        </div>
                    </div>

                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q4.</span>
                            <span class="question-type error">Find Error</span>
                        </div>
                        <p><strong>What's wrong with this copy constructor?</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">class StringClass {
private:
    char* str;
    int length;
public:
    StringClass(const StringClass& other) {  // Copy constructor
        length = other.length;
        str = other.str;  // Error here
    }
};</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Shallow copy - both objects will point to the same memory.</p>
                            <p><strong>Correction:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">StringClass(const StringClass& other) {
    length = other.length;
    str = new char[length + 1];  // Allocate new memory
    strcpy(str, other.str);      // Copy the actual data
}</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Shallow copy causes both objects to share the same memory. When one object is destroyed, it deletes the memory, leaving the other object with a dangling pointer. Deep copy allocates separate memory for each object.</p>
                        </div>
                    </div>
                </div>

                <!-- Find Output Questions -->
                <div class="question-category">
                    <h4>Find the Output</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q5.</span>
                            <span class="question-type output">Find Output</span>
                        </div>
                        <p><strong>What will be the output?</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Point {
private:
    int x, y;
public:
    Point(int a = 0, int b = 0) : x(a), y(b) {}
    
    Point operator+(const Point& other) const {
        return Point(x + other.x, y + other.y);
    }
    
    void display() const {
        cout << "(" << x << ", " << y << ")";
    }
};

int main() {
    Point p1(3, 4);
    Point p2(1, 2);
    Point p3 = p1 + p2;
    
    p1.display(); cout << " + ";
    p2.display(); cout << " = ";
    p3.display(); cout << endl;
    
    return 0;
}</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Output:</strong></p>
                            <pre>(3, 4) + (1, 2) = (4, 6)</pre>
                            <p><strong>Explanation:</strong> The + operator is overloaded to add corresponding coordinates. p1(3,4) + p2(1,2) creates a new Point with coordinates (3+1, 4+2) = (4, 6).</p>
                        </div>
                    </div>
                </div>

                <!-- Complete the Code Questions -->
                <div class="question-category">
                    <h4>Complete the Code</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q6.</span>
                            <span class="question-type complete">Complete Code</span>
                        </div>
                        <p><strong>Complete the FeetInches class with comparison operators:</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">class FeetInches {
private:
    int feet, inches;
public:
    FeetInches(int f = 0, int i = 0) : feet(f), inches(i) {
        normalize();
    }
    
    void normalize() {
        if (inches >= 12) {
            feet += inches / 12;
            inches %= 12;
        }
    }
    
    // Complete the <= operator
    bool operator<=(________) ________ {
        int total1 = ________;
        int total2 = ________;
        return ________;
    }
    
    // Complete the != operator  
    bool operator!=(________) ________ {
        return ________;
    }
};</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Complete Code:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">class FeetInches {
private:
    int feet, inches;
public:
    FeetInches(int f = 0, int i = 0) : feet(f), inches(i) {
        normalize();
    }
    
    void normalize() {
        if (inches >= 12) {
            feet += inches / 12;
            inches %= 12;
        }
    }
    
    // Complete the <= operator
    bool operator<=(const FeetInches& other) const {
        int total1 = feet * 12 + inches;
        int total2 = other.feet * 12 + other.inches;
        return total1 <= total2;
    }
    
    // Complete the != operator  
    bool operator!=(const FeetInches& other) const {
        return !(feet == other.feet && inches == other.inches);
    }
};</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Convert both measurements to total inches for easy comparison. The != operator can be implemented by negating the equality check.</p>
                        </div>
                    </div>
                </div>

                <!-- Lab Exercise Questions -->
                <div class="question-category">
                    <h4>Lab Exercise Questions</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q7.</span>
                            <span class="question-type lab">Lab Exercise</span>
                        </div>
                        <p><strong>Create a LandTract class that is composed of two FeetInches objects for length and width. Include a member function that returns the tract's area.</strong></p>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class FeetInches {
private:
    int feet, inches;
    
    void normalize() {
        if (inches >= 12) {
            feet += inches / 12;
            inches %= 12;
        }
        if (inches < 0) {
            feet--;
            inches += 12;
        }
    }

public:
    FeetInches(int f = 0, int i = 0) : feet(f), inches(i) {
        normalize();
    }
    
    // Convert to total inches for calculations
    int toInches() const {
        return feet * 12 + inches;
    }
    
    // Multiply two FeetInches objects
    FeetInches multiply(const FeetInches& other) const {
        int totalInches = toInches() * other.toInches();
        return FeetInches(0, totalInches);
    }
    
    void display() const {
        cout << feet << " feet, " << inches << " inches";
    }
    
    bool operator==(const FeetInches& other) const {
        return (feet == other.feet && inches == other.inches);
    }
};

class LandTract {
private:
    FeetInches length;
    FeetInches width;

public:
    LandTract(const FeetInches& l, const FeetInches& w) 
        : length(l), width(w) {}
    
    FeetInches getArea() const {
        return length.multiply(width);
    }
    
    void displayTract() const {
        cout << "Length: "; length.display(); cout << endl;
        cout << "Width: "; width.display(); cout << endl;
        cout << "Area: "; getArea().display(); cout << endl;
    }
    
    bool operator==(const LandTract& other) const {
        FeetInches area1 = getArea();
        FeetInches area2 = other.getArea();
        return area1 == area2;
    }
};

int main() {
    // Create two land tracts
    FeetInches length1(100, 6);
    FeetInches width1(50, 8);
    LandTract tract1(length1, width1);
    
    FeetInches length2(75, 10);
    FeetInches width2(67, 2);
    LandTract tract2(length2, width2);
    
    cout << "=== Tract 1 ===" << endl;
    tract1.displayTract();
    
    cout << "\n=== Tract 2 ===" << endl;
    tract2.displayTract();
    
    cout << "\nAre the tracts equal in size? " 
         << (tract1 == tract2 ? "Yes" : "No") << endl;
    
    return 0;
}</code></pre>
                            </div>
                            <p><strong>Key Points:</strong></p>
                            <ul>
                                <li><strong>Composition:</strong> LandTract "has-a" length and width (FeetInches objects)</li>
                                <li><strong>Area calculation:</strong> Multiply length by width</li>
                                <li><strong>Operator overloading:</strong> Implement == to compare tract sizes</li>
                                <li><strong>Encapsulation:</strong> Hide implementation details in private methods</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 1: Time Class with Operator Overloading</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;iomanip&gt;
using namespace std;

class Time {
private:
    int hours, minutes, seconds;

public:
    // Constructors
    Time() : hours(0), minutes(0), seconds(0) {}
    
    Time(int h, int m, int s) {
        setTime(h, m, s);
    }
    
    // Set time with validation
    void setTime(int h, int m, int s) {
        hours = (h >= 0 && h < 24) ? h : 0;
        minutes = (m >= 0 && m < 60) ? m : 0;
        seconds = (s >= 0 && s < 60) ? s : 0;
    }
    
    // Display time in HH:MM:SS format
    void display() const {
        cout << setfill('0') << setw(2) << hours << ":"
             << setw(2) << minutes << ":"
             << setw(2) << seconds;
    }
    
    // Overload + operator
    Time operator+(const Time& other) const {
        Time result;
        result.seconds = seconds + other.seconds;
        result.minutes = minutes + other.minutes + (result.seconds / 60);
        result.seconds %= 60;
        result.hours = hours + other.hours + (result.minutes / 60);
        result.minutes %= 60;
        result.hours %= 24;  // Keep within 24-hour format
        return result;
    }
    
    // Accessors
    int getHours() const { return hours; }
    int getMinutes() const { return minutes; }
    int getSeconds() const { return seconds; }
};

int main() {
    const Time time1(10, 30, 45);
    const Time time2(5, 45, 20);
    Time result;
    
    cout << "Time 1: ";
    time1.display();
    cout << "\nTime 2: ";
    time2.display();
    
    result = time1 + time2;
    
    cout << "\nSum: ";
    result.display();
    cout << endl;
    
    return 0;
}</code></pre>
                </div>

                <div class="output-container">
                    <h4>Sample Output</h4>
                    <pre>Time 1: 10:30:45
Time 2: 05:45:20
Sum: 16:16:05</pre>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 2: FeetInches Class with Extended Operators</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class FeetInches {
private:
    int feet;
    int inches;
    
    void simplify() {
        if (inches >= 12) {
            feet += inches / 12;
            inches %= 12;
        } else if (inches < 0) {
            feet -= ((-inches - 1) / 12) + 1;
            inches = 12 - ((-inches) % 12);
            if (inches == 12) {
                inches = 0;
                feet++;
            }
        }
    }

public:
    // Constructors
    FeetInches(int f = 0, int i = 0) : feet(f), inches(i) {
        simplify();
    }
    
    // Copy constructor
    FeetInches(const FeetInches& other) {
        feet = other.feet;
        inches = other.inches;
    }
    
    // Overloaded operators
    bool operator<=(const FeetInches& other) const {
        return (feet * 12 + inches) <= (other.feet * 12 + other.inches);
    }
    
    bool operator>=(const FeetInches& other) const {
        return (feet * 12 + inches) >= (other.feet * 12 + other.inches);
    }
    
    bool operator!=(const FeetInches& other) const {
        return !(*this == other);
    }
    
    bool operator==(const FeetInches& other) const {
        return (feet == other.feet && inches == other.inches);
    }
    
    // Multiply member function
    FeetInches multiply(const FeetInches& other) const {
        int totalInches1 = feet * 12 + inches;
        int totalInches2 = other.feet * 12 + other.inches;
        int resultInches = totalInches1 * totalInches2;
        return FeetInches(0, resultInches);
    }
    
    // Display function
    void display() const {
        cout << feet << " feet, " << inches << " inches";
    }
    
    // Accessors
    int getFeet() const { return feet; }
    int getInches() const { return inches; }
};

int main() {
    FeetInches distance1(5, 8);
    FeetInches distance2(3, 10);
    FeetInches distance3(5, 8);  // Same as distance1
    
    cout << "Distance 1: "; distance1.display(); cout << endl;
    cout << "Distance 2: "; distance2.display(); cout << endl;
    cout << "Distance 3: "; distance3.display(); cout << endl;
    
    // Test comparison operators
    cout << "\nComparisons:" << endl;
    cout << "Distance1 <= Distance2: " << (distance1 <= distance2) << endl;
    cout << "Distance1 >= Distance2: " << (distance1 >= distance2) << endl;
    cout << "Distance1 != Distance2: " << (distance1 != distance2) << endl;
    cout << "Distance1 == Distance3: " << (distance1 == distance3) << endl;
    
    // Test multiply function
    FeetInches result = distance1.multiply(FeetInches(0, 2));
    cout << "\nDistance1 multiplied by 2 inches: ";
    result.display();
    cout << endl;
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Week 16 Content -->
        <section id="week16" class="week-content">
            <h2><i class="fas fa-sitemap"></i> Week 16 - Inheritance</h2>
            
            <div class="concept-card">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Inheritance:</strong> Creating new classes based on existing classes</li>
                    <li><strong>Base Class:</strong> The parent class being inherited from</li>
                    <li><strong>Derived Class:</strong> The child class that inherits</li>
                    <li><strong>Access Specifiers:</strong> public, protected, private inheritance</li>
                    <li><strong>Constructor Chaining:</strong> How constructors are called in inheritance</li>
                </ul>
            </div>

            <div class="exercise-card">
                <h3>Exercise 1: Employee Hierarchy</h3>
                <div class="code-container">
                    <h4>Base Classes</h4>
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

// Employee base class
class Employee {
protected:
    string name;
    int employeeNumber;

public:
    Employee() : name(""), employeeNumber(0) {}
    
    Employee(string n, int num) : name(n), employeeNumber(num) {}
    
    virtual void getData() {
        cout << "Enter employee name: ";
        getline(cin, name);
        cout << "Enter employee number: ";
        cin >> employeeNumber;
        cin.ignore(); // Clear input buffer
    }
    
    virtual void putData() const {
        cout << "Name: " << name << endl;
        cout << "Employee Number: " << employeeNumber << endl;
    }
    
    virtual ~Employee() {} // Virtual destructor
};

// Student base class
class Student {
protected:
    string school;
    string degree;

public:
    Student() : school(""), degree("") {}
    
    Student(string s, string d) : school(s), degree(d) {}
    
    virtual void getData() {
        cout << "Enter school: ";
        getline(cin, school);
        cout << "Enter degree: ";
        getline(cin, degree);
    }
    
    virtual void putData() const {
        cout << "School: " << school << endl;
        cout << "Degree: " << degree << endl;
    }
    
    virtual ~Student() {}
};</code></pre>
                </div>

                <div class="code-container">
                    <h4>Derived Classes</h4>
                    <pre><code class="language-cpp">// Manager class (multiple inheritance)
class Manager : public Employee, public Student {
private:
    string title;
    double dues;

public:
    Manager() : Employee(), Student(), title(""), dues(0.0) {}
    
    void getData() override {
        Employee::getData();
        Student::getData();
        cout << "Enter title: ";
        getline(cin, title);
        cout << "Enter dues: $";
        cin >> dues;
        cin.ignore();
    }
    
    void putData() const override {
        cout << "\n--- Manager Information ---" << endl;
        Employee::putData();
        Student::putData();
        cout << "Title: " << title << endl;
        cout << "Dues: $" << dues << endl;
    }
};

// Scientist class (multiple inheritance)
class Scientist : public Employee, public Student {
private:
    int publications;

public:
    Scientist() : Employee(), Student(), publications(0) {}
    
    void getData() override {
        Employee::getData();
        Student::getData();
        cout << "Enter number of publications: ";
        cin >> publications;
        cin.ignore();
    }
    
    void putData() const override {
        cout << "\n--- Scientist Information ---" << endl;
        Employee::putData();
        Student::putData();
        cout << "Publications: " << publications << endl;
    }
};

// Laborer class (single inheritance)
class Laborer : public Employee {
public:
    Laborer() : Employee() {}
    
    void getData() override {
        Employee::getData();
    }
    
    void putData() const override {
        cout << "\n--- Laborer Information ---" << endl;
        Employee::putData();
    }
};</code></pre>
                </div>

                <div class="code-container">
                    <h4>Main Program</h4>
                    <pre><code class="language-cpp">int main() {
    Manager mgr;
    Scientist sci;
    Laborer lab;
    
    cout << "=== Enter Manager Data ===" << endl;
    mgr.getData();
    
    cout << "\n=== Enter Scientist Data ===" << endl;
    sci.getData();
    
    cout << "\n=== Enter Laborer Data ===" << endl;
    lab.getData();
    
    cout << "\n\n=== DISPLAYING ALL DATA ===" << endl;
    mgr.putData();
    sci.putData();
    lab.putData();
    
    return 0;
}</code></pre>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 2: ProductionWorker and TeamLeader</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Employee {
protected:
    string name;
    int employeeNumber;
    string hireDate;

public:
    Employee() : name(""), employeeNumber(0), hireDate("") {}
    
    Employee(string n, int num, string date) 
        : name(n), employeeNumber(num), hireDate(date) {}
    
    // Accessors
    string getName() const { return name; }
    int getEmployeeNumber() const { return employeeNumber; }
    string getHireDate() const { return hireDate; }
    
    // Mutators
    void setName(string n) { name = n; }
    void setEmployeeNumber(int num) { employeeNumber = num; }
    void setHireDate(string date) { hireDate = date; }
    
    virtual void displayInfo() const {
        cout << "Name: " << name << endl;
        cout << "Employee Number: " << employeeNumber << endl;
        cout << "Hire Date: " << hireDate << endl;
    }
};

class ProductionWorker : public Employee {
protected:
    int shift;          // 1 = day, 2 = night
    double hourlyPayRate;

public:
    ProductionWorker() : Employee(), shift(1), hourlyPayRate(0.0) {}
    
    ProductionWorker(string n, int num, string date, int s, double pay)
        : Employee(n, num, date), shift(s), hourlyPayRate(pay) {}
    
    // Accessors
    int getShift() const { return shift; }
    double getHourlyPayRate() const { return hourlyPayRate; }
    
    // Mutators
    void setShift(int s) { 
        shift = (s == 1 || s == 2) ? s : 1; 
    }
    void setHourlyPayRate(double pay) { 
        hourlyPayRate = (pay >= 0) ? pay : 0; 
    }
    
    string getShiftName() const {
        return (shift == 1) ? "Day" : "Night";
    }
    
    void displayInfo() const override {
        Employee::displayInfo();
        cout << "Shift: " << getShiftName() << endl;
        cout << "Hourly Pay Rate: $" << hourlyPayRate << endl;
    }
};

class TeamLeader : public ProductionWorker {
private:
    double monthlyBonus;
    int requiredTrainingHours;
    int attendedTrainingHours;

public:
    TeamLeader() : ProductionWorker(), monthlyBonus(0.0), 
                   requiredTrainingHours(0), attendedTrainingHours(0) {}
    
    TeamLeader(string n, int num, string date, int s, double pay,
               double bonus, int reqHours, int attHours)
        : ProductionWorker(n, num, date, s, pay), monthlyBonus(bonus),
          requiredTrainingHours(reqHours), attendedTrainingHours(attHours) {}
    
    // Accessors
    double getMonthlyBonus() const { return monthlyBonus; }
    int getRequiredTrainingHours() const { return requiredTrainingHours; }
    int getAttendedTrainingHours() const { return attendedTrainingHours; }
    
    // Mutators
    void setMonthlyBonus(double bonus) { 
        monthlyBonus = (bonus >= 0) ? bonus : 0; 
    }
    void setRequiredTrainingHours(int hours) { 
        requiredTrainingHours = (hours >= 0) ? hours : 0; 
    }
    void setAttendedTrainingHours(int hours) { 
        attendedTrainingHours = (hours >= 0) ? hours : 0; 
    }
    
    bool hasMetTrainingRequirement() const {
        return attendedTrainingHours >= requiredTrainingHours;
    }
    
    void displayInfo() const override {
        cout << "\n--- Team Leader Information ---" << endl;
        ProductionWorker::displayInfo();
        cout << "Monthly Bonus: $" << monthlyBonus << endl;
        cout << "Required Training Hours: " << requiredTrainingHours << endl;
        cout << "Attended Training Hours: " << attendedTrainingHours << endl;
        cout << "Training Requirement Met: " << (hasMetTrainingRequirement() ? "Yes" : "No") << endl;
    }
};

int main() {
    // Create a TeamLeader object
    TeamLeader leader("John Smith", 12345, "2023-01-15", 1, 25.50, 500.0, 40, 35);
    
    leader.displayInfo();
    
    cout << "\nUpdating training hours..." << endl;
    leader.setAttendedTrainingHours(45);
    
    cout << "\nUpdated Information:" << endl;
    leader.displayInfo();
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Week 17 Content -->
        <section id="week17" class="week-content">
            <h2><i class="fas fa-layer-group"></i> Week 17 - Polymorphism & Virtual Functions</h2>
            
            <div class="concept-card">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Polymorphism:</strong> Objects of different types responding to the same interface</li>
                    <li><strong>Virtual Functions:</strong> Functions that can be overridden in derived classes</li>
                    <li><strong>Pure Virtual Functions:</strong> Functions that must be implemented by derived classes</li>
                    <li><strong>Abstract Classes:</strong> Classes with at least one pure virtual function</li>
                    <li><strong>Dynamic Binding:</strong> Runtime determination of which function to call</li>
                </ul>
            </div>

            <div class="exercise-card">
                <h3>Exercise 1: Publication Hierarchy with Virtual Functions</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Publication {
protected:
    string title;
    float price;

public:
    Publication() : title(""), price(0.0) {}
    
    virtual void getdata() {
        cout << "Enter title: ";
        getline(cin, title);
        cout << "Enter price: $";
        cin >> price;
        cin.ignore();
    }
    
    virtual void putdata() const {
        cout << "Title: " << title << endl;
        cout << "Price: $" << price << endl;
    }
    
    virtual ~Publication() {} // Virtual destructor
};

class Book : public Publication {
private:
    int pageCount;

public:
    Book() : Publication(), pageCount(0) {}
    
    void getdata() override {
        Publication::getdata();
        cout << "Enter page count: ";
        cin >> pageCount;
        cin.ignore();
    }
    
    void putdata() const override {
        cout << "\n--- Book Information ---" << endl;
        Publication::putdata();
        cout << "Page Count: " << pageCount << endl;
    }
};

class Tape : public Publication {
private:
    float playingTime; // in minutes

public:
    Tape() : Publication(), playingTime(0.0) {}
    
    void getdata() override {
        Publication::getdata();
        cout << "Enter playing time (minutes): ";
        cin >> playingTime;
        cin.ignore();
    }
    
    void putdata() const override {
        cout << "\n--- Tape Information ---" << endl;
        Publication::putdata();
        cout << "Playing Time: " << playingTime << " minutes" << endl;
    }
};

int main() {
    Book book;
    Tape tape;
    
    cout << "=== Enter Book Data ===" << endl;
    book.getdata();
    
    cout << "\n=== Enter Tape Data ===" << endl;
    tape.getdata();
    
    cout << "\n=== Displaying Data ===" << endl;
    book.putdata();
    tape.putdata();
    
    // Demonstrating polymorphism
    Publication* publications[2] = {&book, &tape};
    
    cout << "\n=== Polymorphic Display ===" << endl;
    for (int i = 0; i < 2; i++) {
        publications[i]->putdata();
    }
    
    return 0;
}</code></pre>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 2: Abstract Shape Classes</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

// Abstract base class
class BasicShape {
private:
    double area;

public:
    BasicShape() : area(0.0) {}
    
    double getArea() const {
        return area;
    }
    
    // Pure virtual function makes this an abstract class
    virtual void calcArea() = 0;
    
    virtual ~BasicShape() {}

protected:
    void setArea(double a) {
        area = a;
    }
};

class Circle : public BasicShape {
private:
    long centerX, centerY;
    double radius;

public:
    Circle(long x, long y, double r) : centerX(x), centerY(y), radius(r) {
        calcArea();
    }
    
    long getCenterX() const { return centerX; }
    long getCenterY() const { return centerY; }
    double getRadius() const { return radius; }
    
    void calcArea() override {
        double area = 3.14159 * radius * radius;
        setArea(area);
    }
    
    void display() const {
        cout << "Circle at (" << centerX << ", " << centerY << ")" << endl;
        cout << "Radius: " << radius << endl;
        cout << "Area: " << getArea() << endl;
    }
};

class Rectangle : public BasicShape {
private:
    long width, length;

public:
    Rectangle(long w, long l) : width(w), length(l) {
        calcArea();
    }
    
    long getWidth() const { return width; }
    long getLength() const { return length; }
    
    void calcArea() override {
        double area = length * width;
        setArea(area);
    }
    
    void display() const {
        cout << "Rectangle " << width << " x " << length << endl;
        cout << "Area: " << getArea() << endl;
    }
};

int main() {
    Circle circle(0, 0, 5.0);
    Rectangle rectangle(10, 15);
    
    cout << "=== Circle Information ===" << endl;
    circle.display();
    
    cout << "\n=== Rectangle Information ===" << endl;
    rectangle.display();
    
    // Using polymorphism
    BasicShape* shapes[2] = {&circle, &rectangle};
    
    cout << "\n=== Polymorphic Area Calculation ===" << endl;
    for (int i = 0; i < 2; i++) {
        cout << "Shape " << (i+1) << " area: " << shapes[i]->getArea() << endl;
    }
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Week 18 Content -->
        <section id="week18" class="week-content">
            <h2><i class="fas fa-cogs"></i> Week 18 - Templates & Exception Handling</h2>
            
            <div class="concept-card">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Function Templates:</strong> Generic functions that work with multiple data types</li>
                    <li><strong>Class Templates:</strong> Generic classes for creating type-safe containers</li>
                    <li><strong>Exception Handling:</strong> try, catch, throw statements</li>
                    <li><strong>Standard Exceptions:</strong> Built-in exception classes</li>
                    <li><strong>Custom Exceptions:</strong> Creating your own exception classes</li>
                </ul>
            </div>

            <div class="exercise-card">
                <h3>Exercise 1: Function Templates</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;cmath&gt;
using namespace std;

// Template for finding minimum
template &lt;typename T&gt;
T minimum(T a, T b) {
    return (a < b) ? a : b;
}

// Template for finding maximum
template &lt;typename T&gt;
T maximum(T a, T b) {
    return (a > b) ? a : b;
}

// Template for absolute value
template &lt;typename T&gt;
T absolute(T value) {
    return (value < 0) ? -value : value;
}

int main() {
    // Test with integers
    cout << "=== Integer Tests ===" << endl;
    cout << "min(10, 5) = " << minimum(10, 5) << endl;
    cout << "max(10, 5) = " << maximum(10, 5) << endl;
    cout << "abs(-15) = " << absolute(-15) << endl;
    
    // Test with doubles
    cout << "\n=== Double Tests ===" << endl;
    cout << "min(3.7, 8.2) = " << minimum(3.7, 8.2) << endl;
    cout << "max(3.7, 8.2) = " << maximum(3.7, 8.2) << endl;
    cout << "abs(-5.5) = " << absolute(-5.5) << endl;
    
    // Test with characters
    cout << "\n=== Character Tests ===" << endl;
    cout << "min('a', 'z') = " << minimum('a', 'z') << endl;
    cout << "max('a', 'z') = " << maximum('a', 'z') << endl;
    
    // Test with strings
    cout << "\n=== String Tests ===" << endl;
    string str1 = "apple", str2 = "banana";
    cout << "min(\"apple\", \"banana\") = " << minimum(str1, str2) << endl;
    cout << "max(\"apple\", \"banana\") = " << maximum(str1, str2) << endl;
    
    return 0;
}</code></pre>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 2: Exception Handling with TestScores</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

class TestScores {
private:
    double* scores;
    int numScores;

public:
    TestScores(double testScores[], int size) {
        numScores = size;
        scores = new double[numScores];
        
        // Validate and copy scores
        for (int i = 0; i < numScores; i++) {
            if (testScores[i] < 0 || testScores[i] > 100) {
                delete[] scores; // Clean up allocated memory
                throw invalid_argument("Test score must be between 0 and 100");
            }
            scores[i] = testScores[i];
        }
    }
    
    ~TestScores() {
        delete[] scores;
    }
    
    double getAverage() const {
        double sum = 0;
        for (int i = 0; i < numScores; i++) {
            sum += scores[i];
        }
        return sum / numScores;
    }
    
    void displayScores() const {
        cout << "Test Scores: ";
        for (int i = 0; i < numScores; i++) {
            cout << scores[i];
            if (i < numScores - 1) cout << ", ";
        }
        cout << endl;
    }
};

// Custom exception class
class InvalidScoreException : public exception {
private:
    string message;
public:
    InvalidScoreException(const string& msg) : message(msg) {}
    const char* what() const noexcept override {
        return message.c_str();
    }
};

int main() {
    try {
        // Test with valid scores
        cout << "=== Test 1: Valid Scores ===" << endl;
        double validScores[] = {85.5, 92.0, 78.5, 96.0, 88.0};
        TestScores test1(validScores, 5);
        test1.displayScores();
        cout << "Average: " << test1.getAverage() << endl;
        
        // Test with invalid score
        cout << "\n=== Test 2: Invalid Score ===" << endl;
        double invalidScores[] = {85.5, 105.0, 78.5}; // 105 is invalid
        TestScores test2(invalidScores, 3);
        test2.displayScores();
        
    } catch (const invalid_argument& e) {
        cout << "Error: " << e.what() << endl;
    }
    
    try {
        // Test with negative score
        cout << "\n=== Test 3: Negative Score ===" << endl;
        double negativeScores[] = {85.5, -10.0, 78.5}; // -10 is invalid
        TestScores test3(negativeScores, 3);
        
    } catch (const invalid_argument& e) {
        cout << "Error: " << e.what() << endl;
    }
    
    return 0;
}</code></pre>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 3: Account Class with Exception Handling</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
#include &lt;string&gt;
using namespace std;

// Custom exception classes
class InsufficientFundsException : public exception {
private:
    string message;
public:
    InsufficientFundsException(const string& msg) : message(msg) {}
    const char* what() const noexcept override {
        return message.c_str();
    }
};

class InvalidAmountException : public exception {
private:
    string message;
public:
    InvalidAmountException(const string& msg) : message(msg) {}
    const char* what() const noexcept override {
        return message.c_str();
    }
};

class Account {
private:
    double balance;

public:
    Account() : balance(0.0) {}
    
    Account(double initialDeposit) {
        if (initialDeposit < 0) {
            throw InvalidAmountException("Initial deposit cannot be negative");
        }
        balance = initialDeposit;
    }
    
    double getBalance() const {
        return balance;
    }
    
    void deposit(double amount) {
        if (amount <= 0) {
            throw InvalidAmountException("Deposit amount must be positive");
        }
        balance += amount;
    }
    
    void withdraw(double amount) {
        if (amount <= 0) {
            throw InvalidAmountException("Withdrawal amount must be positive");
        }
        if (amount > balance) {
            throw InsufficientFundsException("Insufficient funds for withdrawal");
        }
        balance -= amount;
    }
};

int main() {
    try {
        // Create account with initial deposit
        Account account(1000.0);
        cout << "Account created with balance: $" << account.getBalance() << endl;
        
        // Valid deposit
        account.deposit(250.0);
        cout << "After deposit of $250: $" << account.getBalance() << endl;
        
        // Valid withdrawal
        account.withdraw(150.0);
        cout << "After withdrawal of $150: $" << account.getBalance() << endl;
        
        // Test invalid operations
        cout << "\nTesting invalid operations..." << endl;
        
        try {
            account.deposit(-50.0); // Should throw exception
        } catch (const InvalidAmountException& e) {
            cout << "Deposit error: " << e.what() << endl;
        }
        
        try {
            account.withdraw(2000.0); // Should throw exception
        } catch (const InsufficientFundsException& e) {
            cout << "Withdrawal error: " << e.what() << endl;
        }
        
        try {
            account.withdraw(-100.0); // Should throw exception
        } catch (const InvalidAmountException& e) {
            cout << "Withdrawal error: " << e.what() << endl;
        }
        
        cout << "Final balance: $" << account.getBalance() << endl;
        
    } catch (const exception& e) {
        cout << "Account creation error: " << e.what() << endl;
    }
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Week 19 Content -->
        <section id="week19" class="week-content">
            <h2><i class="fas fa-link"></i> Week 19 - Linked Lists</h2>
            
            <!-- Notes Section -->
            <div class="notes-section">
                <h3><i class="fas fa-book"></i> Detailed Notes</h3>
                
                <div class="concept-card">
                    <h4>What is a Linked List?</h4>
                    <p>A linked list is a dynamic data structure where elements (nodes) are stored in sequence, but not in contiguous memory locations. Each node contains data and a pointer to the next node.</p>
                    
                    <h5>Why Use Linked Lists?</h5>
                    <ul>
                        <li><strong>Dynamic size:</strong> Can grow or shrink during runtime</li>
                        <li><strong>Efficient insertion/deletion:</strong> O(1) at known positions</li>
                        <li><strong>Memory efficient:</strong> Only allocates memory when needed</li>
                        <li><strong>No memory waste:</strong> Unlike arrays with fixed size</li>
                    </ul>
                </div>

                <div class="concept-card">
                    <h4>Linked List Components</h4>
                    
                    <div class="component-item">
                        <h5>Node Structure</h5>
                        <div class="code-container">
                            <pre><code class="language-cpp">class Node {
public:
    int data;        // Stores the actual value
    Node* next;      // Points to next node
    
    Node(int value) : data(value), next(nullptr) {}
};</code></pre>
                        </div>
                    </div>

                    <div class="component-item">
                        <h5>Head Pointer</h5>
                        <p>Points to the first node in the list. If head is nullptr, the list is empty.</p>
                    </div>
                </div>

                <div class="concept-card">
                    <h4>Basic Operations</h4>
                    
                    <table class="operations-table">
                        <tr>
                            <th>Operation</th>
                            <th>Time Complexity</th>
                            <th>Description</th>
                        </tr>
                        <tr>
                            <td>Insert at beginning</td>
                            <td>O(1)</td>
                            <td>Add new node at the start</td>
                        </tr>
                        <tr>
                            <td>Insert at end</td>
                            <td>O(n)</td>
                            <td>Add new node at the end</td>
                        </tr>
                        <tr>
                            <td>Delete</td>
                            <td>O(n)</td>
                            <td>Remove node with specific value</td>
                        </tr>
                        <tr>
                            <td>Search</td>
                            <td>O(n)</td>
                            <td>Find node with specific value</td>
                        </tr>
                        <tr>
                            <td>Traverse</td>
                            <td>O(n)</td>
                            <td>Visit all nodes in sequence</td>
                        </tr>
                    </table>
                </div>

                <div class="concept-card">
                    <h4>Memory Management</h4>
                    <p><strong>Dynamic allocation:</strong> Nodes are created using 'new' and must be deleted using 'delete' to prevent memory leaks.</p>
                    
                    <h5>Important Rules:</h5>
                    <ul>
                        <li>Always check for nullptr before accessing nodes</li>
                        <li>Update pointers carefully to avoid losing nodes</li>
                        <li>Implement destructor to free all allocated memory</li>
                        <li>Consider copy constructor for deep copying</li>
                    </ul>
                </div>
            </div>

            <!-- Questions Section -->
            <div class="questions-section">
                <h3><i class="fas fa-question-circle"></i> Week 19 Practice Questions</h3>

                <!-- MCQ Questions -->
                <div class="question-category">
                    <h4>Multiple Choice Questions</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q1.</span>
                            <span class="question-type mcq">MCQ</span>
                        </div>
                        <p><strong>What is the time complexity of inserting an element at the beginning of a linked list?</strong></p>
                        <div class="mcq-options">
                            <div class="option">A) O(n)</div>
                            <div class="option">B) O(1)</div>
                            <div class="option">C) O(log n)</div>
                            <div class="option">D) O(n²)</div>
                        </div>
                        <div class="answer">
                            <p><strong>Answer: B) O(1)</strong></p>
                            <p><strong>Explanation:</strong> Inserting at the beginning requires only updating the head pointer and the new node's next pointer, regardless of list size. No traversal is needed.</p>
                        </div>
                    </div>

                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q2.</span>
                            <span class="question-type mcq">MCQ</span>
                        </div>
                        <p><strong>Which statement about linked lists is true?</strong></p>
                        <div class="mcq-options">
                            <div class="option">A) Elements are stored in contiguous memory</div>
                            <div class="option">B) Random access is possible</div>
                            <div class="option">C) Size is fixed at compile time</div>
                            <div class="option">D) Memory is allocated dynamically</div>
                        </div>
                        <div class="answer">
                            <p><strong>Answer: D) Memory is allocated dynamically</strong></p>
                            <p><strong>Explanation:</strong> Linked lists allocate memory for nodes as needed during runtime. Elements are not stored contiguously, random access is not possible (must traverse from head), and size can change during execution.</p>
                        </div>
                    </div>
                </div>

                <!-- Find the Error Questions -->
                <div class="question-category">
                    <h4>Find the Error</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q3.</span>
                            <span class="question-type error">Find Error</span>
                        </div>
                        <p><strong>Find the error in this linked list insertion function:</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">void insertAtBeginning(int value) {
    Node* newNode = new Node(value);
    head = newNode;              // Error here
    newNode->next = head;
}</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Order of operations is wrong. Setting head = newNode before newNode->next = head creates a circular reference.</p>
                            <p><strong>Correction:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">void insertAtBeginning(int value) {
    Node* newNode = new Node(value);
    newNode->next = head;        // First: point new node to current head
    head = newNode;              // Then: update head to new node
}</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Must first connect the new node to the existing list, then update the head pointer. Otherwise, the new node points to itself.</p>
                        </div>
                    </div>

                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q4.</span>
                            <span class="question-type error">Find Error</span>
                        </div>
                        <p><strong>What's wrong with this delete function?</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">void deleteValue(int value) {
    Node* current = head;
    while (current != nullptr && current->data != value) {
        current = current->next;
    }
    if (current != nullptr) {
        current->next = current->next->next;  // Error here
        delete current;
    }
}</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Error:</strong> Doesn't handle deletion of the first node, and doesn't properly update previous node's pointer.</p>
                            <p><strong>Correction:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">void deleteValue(int value) {
    if (head == nullptr) return;
    
    // Special case: deleting first node
    if (head->data == value) {
        Node* temp = head;
        head = head->next;
        delete temp;
        return;
    }
    
    // Find the node before the one to delete
    Node* current = head;
    while (current->next != nullptr && current->next->data != value) {
        current = current->next;
    }
    
    if (current->next != nullptr) {
        Node* temp = current->next;
        current->next = current->next->next;
        delete temp;
    }
}</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Need to handle first node deletion separately and keep track of the previous node to properly update links.</p>
                        </div>
                    </div>
                </div>

                <!-- Find Output Questions -->
                <div class="question-category">
                    <h4>Find the Output</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q5.</span>
                            <span class="question-type output">Find Output</span>
                        </div>
                        <p><strong>What will be printed?</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;
public:
    LinkedList() : head(nullptr) {}
    
    void prepend(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        head = newNode;
    }
    
    void print() {
        Node* current = head;
        while (current != nullptr) {
            cout << current->data << " ";
            current = current->next;
        }
        cout << endl;
    }
};

int main() {
    LinkedList list;
    list.prepend(1);
    list.prepend(2);
    list.prepend(3);
    list.print();
    return 0;
}</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Output:</strong></p>
                            <pre>3 2 1 </pre>
                            <p><strong>Explanation:</strong> prepend() adds elements at the beginning. First 1 is added, then 2 is added before 1, then 3 is added before 2. The final order is 3 → 2 → 1.</p>
                        </div>
                    </div>
                </div>

                <!-- Complete the Code Questions -->
                <div class="question-category">
                    <h4>Complete the Code</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q6.</span>
                            <span class="question-type complete">Complete Code</span>
                        </div>
                        <p><strong>Complete the reverse function for a linked list:</strong></p>
                        <div class="code-container">
                            <pre><code class="language-cpp">void reverse() {
    Node* prev = _________;
    Node* current = _________;
    Node* next = nullptr;
    
    while (current != nullptr) {
        next = _________;           // Store next node
        current->next = _________;  // Reverse the link
        prev = _________;           // Move prev forward
        current = _________;        // Move current forward
    }
    
    head = _________;  // Update head
}</code></pre>
                        </div>
                        <div class="answer">
                            <p><strong>Complete Code:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">void reverse() {
    Node* prev = nullptr;
    Node* current = head;
    Node* next = nullptr;
    
    while (current != nullptr) {
        next = current->next;       // Store next node
        current->next = prev;       // Reverse the link
        prev = current;             // Move prev forward
        current = next;             // Move current forward
    }
    
    head = prev;  // Update head to last processed node
}</code></pre>
                            </div>
                            <p><strong>Explanation:</strong> Use three pointers to reverse links one by one. prev tracks the previous node, current is the node being processed, and next stores the next node to avoid losing it.</p>
                        </div>
                    </div>
                </div>

                <!-- Lab Exercise Questions -->
                <div class="question-category">
                    <h4>Lab Exercise Questions</h4>
                    
                    <div class="question-card" onclick="toggleAnswer(this)">
                        <div class="question-header">
                            <span class="question-number">Q7.</span>
                            <span class="question-type lab">Lab Exercise</span>
                        </div>
                        <p><strong>Create a linked list template that includes a search function returning the position of a specific value (-1 if not found).</strong></p>
                        <div class="answer">
                            <p><strong>Solution:</strong></p>
                            <div class="code-container">
                                <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

template &lt;typename T&gt;
class Node {
public:
    T data;
    Node&lt;T&gt;* next;
    
    Node(const T& value) : data(value), next(nullptr) {}
};

template &lt;typename T&gt;
class LinkedList {
private:
    Node&lt;T&gt;* head;

public:
    LinkedList() : head(nullptr) {}
    
    // Copy constructor for deep copying
    LinkedList(const LinkedList&lt;T&gt;& other) : head(nullptr) {
        Node&lt;T&gt;* current = other.head;
        while (current != nullptr) {
            append(current->data);
            current = current->next;
        }
    }
    
    ~LinkedList() {
        clear();
    }
    
    void append(const T& value) {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        
        if (head == nullptr) {
            head = newNode;
        } else {
            Node&lt;T&gt;* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
    }
    
    void insertAt(int position, const T& value) {
        if (position == 0) {
            prepend(value);
            return;
        }
        
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        Node&lt;T&gt;* current = head;
        
        // Navigate to position
        for (int i = 0; i < position - 1 && current != nullptr; i++) {
            current = current->next;
        }
        
        if (current == nullptr) {
            // Position beyond list, append to end
            delete newNode;
            append(value);
        } else {
            newNode->next = current->next;
            current->next = newNode;
        }
    }
    
    void prepend(const T& value) {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        newNode->next = head;
        head = newNode;
    }
    
    // Search function - returns position or -1 if not found
    int search(const T& value) const {
        Node&lt;T&gt;* current = head;
        int position = 0;
        
        while (current != nullptr) {
            if (current->data == value) {
                return position;
            }
            current = current->next;
            position++;
        }
        
        return -1; // Not found
    }
    
    void deleteValue(const T& value) {
        if (head == nullptr) return;
        
        if (head->data == value) {
            Node&lt;T&gt;* temp = head;
            head = head->next;
            delete temp;
            return;
        }
        
        Node&lt;T&gt;* current = head;
        while (current->next != nullptr && current->next->data != value) {
            current = current->next;
        }
        
        if (current->next != nullptr) {
            Node&lt;T&gt;* temp = current->next;
            current->next = current->next->next;
            delete temp;
        }
    }
    
    void reverse() {
        Node&lt;T&gt;* prev = nullptr;
        Node&lt;T&gt;* current = head;
        Node&lt;T&gt;* next = nullptr;
        
        while (current != nullptr) {
            next = current->next;
            current->next = prev;
            prev = current;
            current = next;
        }
        
        head = prev;
    }
    
    void print() const {
        Node&lt;T&gt;* current = head;
        cout << "List: ";
        while (current != nullptr) {
            cout << current->data;
            if (current->next != nullptr) {
                cout << " -> ";
            }
            current = current->next;
        }
        cout << " -> NULL" << endl;
    }
    
    bool isEmpty() const {
        return head == nullptr;
    }
    
    int size() const {
        int count = 0;
        Node&lt;T&gt;* current = head;
        while (current != nullptr) {
            count++;
            current = current->next;
        }
        return count;
    }
    
    void clear() {
        while (head != nullptr) {
            Node&lt;T&gt;* temp = head;
            head = head->next;
            delete temp;
        }
    }
};

// Test program
int main() {
    cout << "=== Testing Linked List Template ===" << endl;
    
    // Test with integers
    LinkedList&lt;int&gt; intList;
    intList.append(10);
    intList.append(20);
    intList.append(30);
    intList.prepend(5);
    intList.print();
    
    cout << "Search for 20: position " << intList.search(20) << endl;
    cout << "Search for 100: position " << intList.search(100) << endl;
    
    // Test insertion at position
    intList.insertAt(2, 15);
    cout << "After inserting 15 at position 2:" << endl;
    intList.print();
    
    // Test with strings
    cout << "\n=== String List ===" << endl;
    LinkedList&lt;string&gt; stringList;
    stringList.append("Apple");
    stringList.append("Banana");
    stringList.append("Cherry");
    stringList.print();
    
    cout << "Search for 'Banana': position " << stringList.search("Banana") << endl;
    
    // Test copy constructor
    cout << "\n=== Testing Copy Constructor ===" << endl;
    LinkedList&lt;int&gt; copyList(intList);
    cout << "Original: ";
    intList.print();
    cout << "Copy: ";
    copyList.print();
    
    // Test reverse
    cout << "\n=== Testing Reverse ===" << endl;
    intList.reverse();
    cout << "Reversed list: ";
    intList.print();
    
    return 0;
}</code></pre>
                            </div>
                            <p><strong>Key Features Implemented:</strong></p>
                            <ul>
                                <li><strong>Template class:</strong> Works with any data type</li>
                                <li><strong>Search function:</strong> Returns position of element or -1</li>
                                <li><strong>Copy constructor:</strong> Deep copying for safe object copying</li>
                                <li><strong>Insert at position:</strong> Flexible insertion at any position</li>
                                <li><strong>Reverse function:</strong> Reverses the entire list</li>
                                <li><strong>Memory management:</strong> Proper cleanup in destructor</li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 1: Basic Linked List Implementation</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Node {
public:
    int data;
    Node* next;
    
    Node(int value) : data(value), next(nullptr) {}
};

class LinkedList {
private:
    Node* head;

public:
    LinkedList() : head(nullptr) {}
    
    // Copy constructor
    LinkedList(const LinkedList& other) : head(nullptr) {
        Node* current = other.head;
        while (current != nullptr) {
            append(current->data);
            current = current->next;
        }
    }
    
    // Destructor
    ~LinkedList() {
        clear();
    }
    
    // Append to end of list
    void append(int value) {
        Node* newNode = new Node(value);
        
        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
    }
    
    // Insert at beginning
    void prepend(int value) {
        Node* newNode = new Node(value);
        newNode->next = head;
        head = newNode;
    }
    
    // Insert at specific position
    void insertAt(int position, int value) {
        if (position == 0) {
            prepend(value);
            return;
        }
        
        Node* newNode = new Node(value);
        Node* current = head;
        
        // Find the position
        for (int i = 0; i < position - 1 && current != nullptr; i++) {
            current = current->next;
        }
        
        if (current == nullptr) {
            // Position is beyond the list, append to end
            delete newNode;
            append(value);
        } else {
            newNode->next = current->next;
            current->next = newNode;
        }
    }
    
    // Delete node with specific value
    void deleteValue(int value) {
        if (head == nullptr) return;
        
        if (head->data == value) {
            Node* temp = head;
            head = head->next;
            delete temp;
            return;
        }
        
        Node* current = head;
        while (current->next != nullptr && current->next->data != value) {
            current = current->next;
        }
        
        if (current->next != nullptr) {
            Node* temp = current->next;
            current->next = current->next->next;
            delete temp;
        }
    }
    
    // Search for a value and return position (-1 if not found)
    int search(int value) const {
        Node* current = head;
        int position = 0;
        
        while (current != nullptr) {
            if (current->data == value) {
                return position;
            }
            current = current->next;
            position++;
        }
        
        return -1; // Not found
    }
    
    // Reverse the linked list
    void reverse() {
        Node* prev = nullptr;
        Node* current = head;
        Node* next = nullptr;
        
        while (current != nullptr) {
            next = current->next;
            current->next = prev;
            prev = current;
            current = next;
        }
        
        head = prev;
    }
    
    // Print the list
    void print() const {
        Node* current = head;
        cout << "List: ";
        while (current != nullptr) {
            cout << current->data;
            if (current->next != nullptr) {
                cout << " -> ";
            }
            current = current->next;
        }
        cout << " -> NULL" << endl;
    }
    
    // Get list size
    int size() const {
        int count = 0;
        Node* current = head;
        while (current != nullptr) {
            count++;
            current = current->next;
        }
        return count;
    }
    
    // Clear the list
    void clear() {
        while (head != nullptr) {
            Node* temp = head;
            head = head->next;
            delete temp;
        }
    }
    
    bool isEmpty() const {
        return head == nullptr;
    }
};

int main() {
    LinkedList list;
    
    cout << "=== Testing Linked List Operations ===" << endl;
    
    // Test append
    cout << "\nAppending values 10, 20, 30:" << endl;
    list.append(10);
    list.append(20);
    list.append(30);
    list.print();
    
    // Test prepend
    cout << "\nPrepending value 5:" << endl;
    list.prepend(5);
    list.print();
    
    // Test insert at position
    cout << "\nInserting 15 at position 2:" << endl;
    list.insertAt(2, 15);
    list.print();
    
    // Test search
    cout << "\nSearching for value 20:" << endl;
    int pos = list.search(20);
    if (pos != -1) {
        cout << "Found at position: " << pos << endl;
    } else {
        cout << "Not found" << endl;
    }
    
    // Test delete
    cout << "\nDeleting value 15:" << endl;
    list.deleteValue(15);
    list.print();
    
    // Test reverse
    cout << "\nReversing the list:" << endl;
    list.reverse();
    list.print();
    
    // Test copy constructor
    cout << "\nTesting copy constructor:" << endl;
    LinkedList listCopy(list);
    cout << "Original: ";
    list.print();
    cout << "Copy: ";
    listCopy.print();
    
    cout << "\nList size: " << list.size() << endl;
    
    return 0;
}</code></pre>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 2: Linked List Template</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

template &lt;typename T&gt;
class Node {
public:
    T data;
    Node&lt;T&gt;* next;
    
    Node(const T& value) : data(value), next(nullptr) {}
};

template &lt;typename T&gt;
class LinkedList {
private:
    Node&lt;T&gt;* head;

public:
    LinkedList() : head(nullptr) {}
    
    ~LinkedList() {
        clear();
    }
    
    void append(const T& value) {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        
        if (head == nullptr) {
            head = newNode;
        } else {
            Node&lt;T&gt;* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
    }
    
    void prepend(const T& value) {
        Node&lt;T&gt;* newNode = new Node&lt;T&gt;(value);
        newNode->next = head;
        head = newNode;
    }
    
    int search(const T& value) const {
        Node&lt;T&gt;* current = head;
        int position = 0;
        
        while (current != nullptr) {
            if (current->data == value) {
                return position;
            }
            current = current->next;
            position++;
        }
        
        return -1; // Not found
    }
    
    void deleteValue(const T& value) {
        if (head == nullptr) return;
        
        if (head->data == value) {
            Node&lt;T&gt;* temp = head;
            head = head->next;
            delete temp;
            return;
        }
        
        Node&lt;T&gt;* current = head;
        while (current->next != nullptr && current->next->data != value) {
            current = current->next;
        }
        
        if (current->next != nullptr) {
            Node&lt;T&gt;* temp = current->next;
            current->next = current->next->next;
            delete temp;
        }
    }
    
    void print() const {
        Node&lt;T&gt;* current = head;
        cout << "List: ";
        while (current != nullptr) {
            cout << current->data;
            if (current->next != nullptr) {
                cout << " -> ";
            }
            current = current->next;
        }
        cout << " -> NULL" << endl;
    }
    
    void clear() {
        while (head != nullptr) {
            Node&lt;T&gt;* temp = head;
            head = head->next;
            delete temp;
        }
    }
    
    bool isEmpty() const {
        return head == nullptr;
    }
    
    int size() const {
        int count = 0;
        Node&lt;T&gt;* current = head;
        while (current != nullptr) {
            count++;
            current = current->next;
        }
        return count;
    }
};

int main() {
    cout << "=== Testing Template Linked List ===" << endl;
    
    // Test with integers
    cout << "\n--- Integer List ---" << endl;
    LinkedList&lt;int&gt; intList;
    intList.append(10);
    intList.append(20);
    intList.append(30);
    intList.prepend(5);
    intList.print();
    
    cout << "Searching for 20: position " << intList.search(20) << endl;
    cout << "Searching for 100: position " << intList.search(100) << endl;
    
    // Test with strings
    cout << "\n--- String List ---" << endl;
    LinkedList&lt;string&gt; stringList;
    stringList.append("Apple");
    stringList.append("Banana");
    stringList.append("Cherry");
    stringList.prepend("Avocado");
    stringList.print();
    
    cout << "Searching for \"Banana\": position " << stringList.search("Banana") << endl;
    
    // Test with doubles
    cout << "\n--- Double List ---" << endl;
    LinkedList&lt;double&gt; doubleList;
    doubleList.append(3.14);
    doubleList.append(2.71);
    doubleList.append(1.41);
    doubleList.print();
    
    cout << "List size: " << doubleList.size() << endl;
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Week 20 Content -->
        <section id="week20" class="week-content">
            <h2><i class="fas fa-layer-group"></i> Week 20 - Stacks & Queues</h2>
            
            <div class="concept-card">
                <h3>Key Concepts</h3>
                <ul>
                    <li><strong>Stack:</strong> LIFO (Last In, First Out) data structure</li>
                    <li><strong>Queue:</strong> FIFO (First In, First Out) data structure</li>
                    <li><strong>Push/Pop:</strong> Stack operations for adding/removing elements</li>
                    <li><strong>Enqueue/Dequeue:</strong> Queue operations for adding/removing elements</li>
                    <li><strong>Static vs Dynamic:</strong> Array-based vs pointer-based implementations</li>
                </ul>
            </div>

            <div class="exercise-card">
                <h3>Exercise 1: Static Stack Template</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

template &lt;typename T&gt;
class Stack {
private:
    T* stackArray;
    int stackSize;
    int top;

public:
    Stack(int size) {
        stackArray = new T[size];
        stackSize = size;
        top = -1;
    }
    
    ~Stack() {
        delete[] stackArray;
    }
    
    void push(const T& value) {
        if (isFull()) {
            throw overflow_error("Stack overflow: Cannot push to full stack");
        }
        stackArray[++top] = value;
    }
    
    T pop() {
        if (isEmpty()) {
            throw underflow_error("Stack underflow: Cannot pop from empty stack");
        }
        return stackArray[top--];
    }
    
    T peek() const {
        if (isEmpty()) {
            throw underflow_error("Stack is empty: Cannot peek");
        }
        return stackArray[top];
    }
    
    bool isEmpty() const {
        return top == -1;
    }
    
    bool isFull() const {
        return top == stackSize - 1;
    }
    
    int size() const {
        return top + 1;
    }
    
    int capacity() const {
        return stackSize;
    }
    
    void display() const {
        if (isEmpty()) {
            cout << "Stack is empty" << endl;
            return;
        }
        
        cout << "Stack (top to bottom): ";
        for (int i = top; i >= 0; i--) {
            cout << stackArray[i];
            if (i > 0) cout << " <- ";
        }
        cout << endl;
    }
};

int main() {
    try {
        cout << "=== Testing Stack Template ===" << endl;
        
        // Test with integers
        cout << "\n--- Integer Stack ---" << endl;
        Stack&lt;int&gt; intStack(5);
        
        cout << "Pushing values: 10, 20, 30" << endl;
        intStack.push(10);
        intStack.push(20);
        intStack.push(30);
        intStack.display();
        
        cout << "Top element: " << intStack.peek() << endl;
        cout << "Stack size: " << intStack.size() << endl;
        
        cout << "Popping elements:" << endl;
        while (!intStack.isEmpty()) {
            cout << "Popped: " << intStack.pop() << endl;
            intStack.display();
        }
        
        // Test with strings
        cout << "\n--- String Stack ---" << endl;
        Stack&lt;string&gt; stringStack(3);
        
        stringStack.push("First");
        stringStack.push("Second");
        stringStack.push("Third");
        stringStack.display();
        
        cout << "Popped: " << stringStack.pop() << endl;
        stringStack.display();
        
        // Test overflow
        cout << "\n--- Testing Stack Overflow ---" << endl;
        Stack&lt;int&gt; smallStack(2);
        smallStack.push(1);
        smallStack.push(2);
        try {
            smallStack.push(3); // Should throw exception
        } catch (const overflow_error& e) {
            cout << "Caught exception: " << e.what() << endl;
        }
        
    } catch (const exception& e) {
        cout << "Error: " << e.what() << endl;
    }
    
    return 0;
}</code></pre>
                </div>
            </div>

            <div class="exercise-card">
                <h3>Exercise 2: Dynamic Queue Template</h3>
                <div class="code-container">
                    <pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;stdexcept&gt;
using namespace std;

template &lt;typename T&gt;
class QueueNode {
public:
    T data;
    QueueNode&lt;T&gt;* next;
    
    QueueNode(const T& value) : data(value), next(nullptr) {}
};

template &lt;typename T&gt;
class Queue {
private:
    QueueNode&lt;T&gt;* front;
    QueueNode&lt;T&gt;* rear;
    int count;

public:
    Queue() : front(nullptr), rear(nullptr), count(0) {}
    
    ~Queue() {
        clear();
    }
    
    void enqueue(const T& value) {
        QueueNode&lt;T&gt;* newNode = new QueueNode&lt;T&gt;(value);
        
        if (isEmpty()) {
            front = rear = newNode;
        } else {
            rear->next = newNode;
            rear = newNode;
        }
        count++;
    }
    
    T dequeue() {
        if (isEmpty()) {
            throw underflow_error("Queue underflow: Cannot dequeue from empty queue");
        }
        
        QueueNode&lt;T&gt;* temp = front;
        T value = front->data;
        front = front->next;
        
        if (front == nullptr) {
            rear = nullptr;
        }
        
        delete temp;
        count--;
        return value;
    }
    
    T getFront() const {
        if (isEmpty()) {
            throw underflow_error("Queue is empty: Cannot get front element");
        }
        return front->data;
    }
    
    T getRear() const {
        if (isEmpty()) {
            throw underflow_error("Queue is empty: Cannot get rear element");
        }
        return rear->data;
    }
    
    bool isEmpty() const {
        return front == nullptr;
    }
    
    int size() const {
        return count;
    }
    
    void display() const {
        if (isEmpty()) {
            cout << "Queue is empty" << endl;
            return;
        }
        
        cout << "Queue (front to rear): ";
        QueueNode&lt;T&gt;* current = front;
        while (current != nullptr) {
            cout << current->data;
            if (current->next != nullptr) {
                cout << " <- ";
            }
            current = current->next;
        }
        cout << endl;
    }
    
    void clear() {
        while (!isEmpty()) {
            dequeue();
        }
    }
};

// Example: Inventory System using Queue
class InventoryItem {
public:
    int serialNum;
    string manufactDate;
    int lotNum;
    
    InventoryItem(int serial, const string& date, int lot) 
        : serialNum(serial), manufactDate(date), lotNum(lot) {}
    
    void display() const {
        cout << "Serial: " << serialNum << ", Date: " << manufactDate 
             << ", Lot: " << lotNum;
    }
};

int main() {
    try {
        cout << "=== Testing Queue Template ===" << endl;
        
        // Test with integers
        cout << "\n--- Integer Queue ---" << endl;
        Queue&lt;int&gt; intQueue;
        
        cout << "Enqueuing values: 10, 20, 30" << endl;
        intQueue.enqueue(10);
        intQueue.enqueue(20);
        intQueue.enqueue(30);
        intQueue.display();
        
        cout << "Front element: " << intQueue.getFront() << endl;
        cout << "Rear element: " << intQueue.getRear() << endl;
        cout << "Queue size: " << intQueue.size() << endl;
        
        cout << "\nDequeuing elements:" << endl;
        while (!intQueue.isEmpty()) {
            cout << "Dequeued: " << intQueue.dequeue() << endl;
            if (!intQueue.isEmpty()) {
                intQueue.display();
            }
        }
        
        // Test with strings
        cout << "\n--- String Queue ---" << endl;
        Queue&lt;string&gt; stringQueue;
        
        stringQueue.enqueue("First");
        stringQueue.enqueue("Second");
        stringQueue.enqueue("Third");
        stringQueue.display();
        
        cout << "Dequeued: " << stringQueue.dequeue() << endl;
        stringQueue.display();
        
        // Test inventory system
        cout << "\n--- Inventory System Example ---" << endl;
        Queue&lt;InventoryItem&gt; inventory;
        
        inventory.enqueue(InventoryItem(12345, "2024-01-15", 101));
        inventory.enqueue(InventoryItem(12346, "2024-01-16", 102));
        inventory.enqueue(InventoryItem(12347, "2024-01-17", 103));
        
        cout << "Inventory items:" << endl;
        Queue&lt;InventoryItem&gt; tempQueue = inventory; // For display purposes
        int itemNum = 1;
        while (!tempQueue.isEmpty()) {
            cout << "Item " << itemNum++ << ": ";
            tempQueue.dequeue().display();
            cout << endl;
        }
        
        cout << "\nProcessing inventory (FIFO):" << endl;
        while (!inventory.isEmpty()) {
            cout << "Processing: ";
            inventory.dequeue().display();
            cout << endl;
        }
        
    } catch (const exception& e) {
        cout << "Error: " << e.what() << endl;
    }
    
    return 0;
}</code></pre>
                </div>
            </div>
        </section>

        <!-- Quiz Section -->
        <section id="quiz" class="week-content">
            <h2><i class="fas fa-question-circle"></i> Interactive C++ Quiz</h2>
            
            <div class="quiz-container">
                <div id="quiz-question" class="question-card">
                    <h3 id="question-text"></h3>
                    <div id="code-block" class="code-container" style="display: none;">
                        <pre><code id="code-content"></code></pre>
                    </div>
                    <div id="options" class="options-container">
                        <!-- Options will be inserted here -->
                    </div>
                    <button id="submit-answer" onclick="checkAnswer()">Submit Answer</button>
                    <div id="feedback" class="feedback"></div>
                    <button id="next-question" onclick="nextQuestion()" style="display: none;">Next Question</button>
                </div>
                
                <div class="quiz-stats">
                    <p>Question <span id="current-question">1</span> of <span id="total-questions">10</span></p>
                    <p>Score: <span id="score">0</span></p>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 CSY2006 C++ Programming Notes. Created for educational purposes.</p>
        </div>
    </footer>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-cpp.min.js"></script>
    <script src="script.js"></script>
</body>
</html>
